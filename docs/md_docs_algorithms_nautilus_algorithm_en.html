<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fuzzuf: Nautilus</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fuzzuf
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Nautilus </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document explains about Nautilus mode of fuzzuf and its usage.</p>
<h1><a class="anchor" id="autotoc_md153"></a>
1. About Nautilus</h1>
<p>Nautilus[^1] is an <a href="https://github.com/nautilus-fuzz/nautilus/">open-sourced</a> grammar-based fuzzer published in 2019. Nautilus requires the definition of grammar as input instead of some seed test cases and can automatically generate test cases according to the grammar. This kind of fuzzer is classified to a generative fuzzer. In addition, Nautilus is a coverage guided fuzzer, which uses the coverage of the inspection target as an indicator to generate test cases.</p>
<p>Some common fuzzers, such as AFL, mutate test cases by units of bytes or bits. These fuzzers struggle with fuzzing programs that accepts only grammatically-correct inputs such as interpreters of programming languages because the common fuzzers generate tons of grammatically-wrong test cases and most of them result in waste.</p>
<p>To address this problem, researchers have developed grammar-based fuzzers which can generate grammatically-correct test cases. In particular, they focus on developing fuzzers for JavaScript engine as JavaScript, a language widely used by Web browsers, is a good attack surface. However, Nautilus is a generic grammar-based fuzzer which interprets a grammar defined by the user and can generate test cases according to it.</p>
<p>Nautilus has the following features.</p>
<ul>
<li>Requires the source code of an application and the user-defined grammar</li>
<li>Works without input corpus</li>
<li>Takes advantage of coverage feedback</li>
</ul>
<p>The user can define the grammar, which enables to fuzz a specific function of the application, e.g., by removing uninteresting parts of the grammar.</p>
<h1><a class="anchor" id="autotoc_md154"></a>
2. Usage on CLI</h1>
<p>You have to build fuzzuf before using Nautilus mode. Please refer to ../../building.md "this document" for how to build fuzzuf.</p>
<h2><a class="anchor" id="autotoc_md155"></a>
2-1. Preparing Grammar File</h2>
<p>Nautilus can generate test cases according to a grammar defined by the user. You must write the grammar in <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">BNF form</a>.</p>
<h3><a class="anchor" id="autotoc_md156"></a>
2-1-a. Basic Notation</h3>
<p>Let's write a BNF of the arithmetic calculation of integer. </p><div class="fragment"><div class="line">&lt;EXPRESSION&gt; ::= &lt;TERM&gt;</div>
<div class="line">                 | &lt;EXPRESSION&gt; + &lt;EXPRESSION&gt;</div>
<div class="line">                 | &lt;EXPRESSION&gt; - &lt;EXPRESSION&gt;</div>
<div class="line">&lt;TERM&gt; ::= &lt;FACTOR&gt;</div>
<div class="line">           | &lt;FACTOR&gt; * &lt;FACTOR&gt;</div>
<div class="line">           | &lt;FACTOR&gt; / &lt;FACTOR&gt;</div>
<div class="line">&lt;FACTOR&gt; ::= &lt;NUMBER&gt;</div>
<div class="line">             | (&lt;EXPRESSION&gt;)</div>
<div class="line">&lt;NUMBER&gt; ::= &lt;DIGITS&gt;</div>
<div class="line">             | &lt;SIGN&gt;&lt;NUMBER&gt;</div>
<div class="line">             | &lt;DIGITS&gt;&lt;NUMBER&gt;</div>
<div class="line">&lt;SIGN&gt; ::= + | -</div>
<div class="line">&lt;DIGITS&gt; ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</div>
</div><!-- fragment --><p>The symbols enclosed by angle brackets <code>&lt; &gt;</code>, such as <code>&lt;EXPRESSION&gt;</code> or <code>&lt;SIGN&gt;</code>, are called <b>non-terminals</b> and the characters representing specific literals, such as <code>+</code> or <code>1</code>, are called <b>terminals</b>. You have to define the grammar in JSON array to use it in Nautilus like the following way, for example: </p><div class="fragment"><div class="line">[</div>
<div class="line">    [&quot;EXPRESSION&quot;, &quot;{TERM}&quot;],</div>
<div class="line">    [&quot;EXPRESSION&quot;, &quot;{EXPRESSION}+{EXPRESSION}&quot;],</div>
<div class="line">    [&quot;EXPRESSION&quot;, &quot;{EXPRESSION}-{EXPRESSION}&quot;],</div>
<div class="line">    [&quot;TERM&quot;, &quot;{FACTOR}&quot;],</div>
<div class="line">    [&quot;TERM&quot;, &quot;{FACTOR}*{FACTOR}&quot;],</div>
<div class="line">    [&quot;TERM&quot;, &quot;{FACTOR}/{FACTOR}&quot;],</div>
<div class="line">    [&quot;FACTOR&quot;, &quot;{NUMBER}&quot;],</div>
<div class="line">    [&quot;FACTOR&quot;, &quot;({EXPRESSION})&quot;],</div>
<div class="line">    [&quot;NUMBER&quot;, &quot;{DIGITS}&quot;],</div>
<div class="line">    [&quot;NUMBER&quot;, &quot;{SIGN}{NUMBER}&quot;],</div>
<div class="line">    [&quot;NUMBER&quot;, &quot;{DIGITS}{NUMBER}&quot;],</div>
<div class="line">    [&quot;SIGN&quot;, &quot;+&quot;],</div>
<div class="line">    [&quot;SIGN&quot;, &quot;-&quot;],</div>
<div class="line">    [&quot;DIGITS&quot;, &quot;0&quot;],</div>
<div class="line">    [&quot;DIGITS&quot;, &quot;1&quot;],</div>
<div class="line">    [&quot;DIGITS&quot;, &quot;2&quot;],</div>
<div class="line">    [&quot;DIGITS&quot;, &quot;3&quot;],</div>
<div class="line">    [&quot;DIGITS&quot;, &quot;4&quot;],</div>
<div class="line">    [&quot;DIGITS&quot;, &quot;5&quot;],</div>
<div class="line">    [&quot;DIGITS&quot;, &quot;6&quot;],</div>
<div class="line">    [&quot;DIGITS&quot;, &quot;7&quot;],</div>
<div class="line">    [&quot;DIGITS&quot;, &quot;8&quot;],</div>
<div class="line">    [&quot;DIGITS&quot;, &quot;9&quot;]</div>
<div class="line">]</div>
</div><!-- fragment --><p>Each element of the array represents the definition for a non-terminal. The element has 2 string data: the first one is the non-terminal symbol and the second one is the definition (expression) for the non-terminal. You must enclose every non-terminal symbol in the expression by braces <code>{ }</code>. <b>The non-terminal symbol must start with a capital letter.</b> If a part of an expression is enclosed by terminal characters <code>{</code> and <code>}</code>, you must escape them as special symbols to distinguish them from non-terminals. If the definition of a non-terminal includes the pattern, please write like the following, for example: </p><div class="fragment"><div class="line">[</div>
<div class="line">    [&quot;BLOCK&quot;, &quot;\\{ {STATEMENT} \\}&quot;],</div>
<div class="line">    ...</div>
<div class="line">]</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md157"></a>
2-1-b. Merging Multiple Rules</h3>
<p>We split the rules with <code>|</code> (a symbol meaning "or") in the BNF format into multiple rules in the previous example. However, this makes the rule look complicated so the Nautilus mode of fuzzuf also supports the following notation: </p><div class="fragment"><div class="line">[&quot;DIGITS&quot;, [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;]]</div>
</div><!-- fragment --><p>You can use this notation even if the right-hand side expression contains non-terminal symbols. </p><div class="fragment"><div class="line">[&quot;EXPRESSION&quot;, [</div>
<div class="line">  &quot;{TERM}&quot;,</div>
<div class="line">  &quot;{EXPRESSION}+{EXPRESSION}&quot;,</div>
<div class="line">  &quot;{EXPRESSION}-{EXPRESSION}&quot;</div>
<div class="line">]]</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md158"></a>
2-1-c. Binary Data</h3>
<p>The Nautilus mode of fuzzuf is useful not only for generating human-readable inputs for programs such as a calculator or an interpreter but also for generating structured binary files like PDFs. To do so, you need to include some binary data other than ASCII characters in the grammar, but the JSON format doesn't support them. You can write the binary data in the array format like the following in the Nautilus mode of fuzzuf. </p><div class="fragment"><div class="line">[&quot;NULL&quot;, [0]]</div>
</div><!-- fragment --><p>You can also write a sequence of binary data. (Although JSON only supports decimal values, unfortunately.) </p><div class="fragment"><div class="line">[&quot;DEADBEEF&quot;, [239, 190, 173, 222]]</div>
</div><!-- fragment --><p>If the array of binary data contains string, they will be concatenated and recognized as a single rule. In the following rules, for instance, the non-terminal <code>A</code> will be expanded to <code>\x00A\x00BBBB\xFFA\xFF</code>. </p><div class="fragment"><div class="line">[&quot;A&quot;, [0, &quot;A{B}A&quot;, 255]],</div>
<div class="line">[&quot;B&quot;, [0, &quot;BBBB&quot;, 255]],</div>
</div><!-- fragment --><p>You can also use the binary format when you want to merge multiple rules by <code>|</code> symbol. That is to say, </p><div class="fragment"><div class="line">[&quot;A&quot;, [&quot;hello&quot;, [0], [&quot;bye&quot;, 128]]]</div>
</div><!-- fragment --><p>and </p><div class="fragment"><div class="line">[&quot;A&quot;, &quot;hello&quot;],</div>
<div class="line">[&quot;A&quot;, [0]],</div>
<div class="line">[&quot;A&quot;, [&quot;bye&quot;, 128]]</div>
</div><!-- fragment --><p>are equivalent.</p>
<h2><a class="anchor" id="autotoc_md159"></a>
2-2. Testing Grammar Files</h2>
<p>You may want to check if your grammar is correct when it gets complicated. <code>tools/nautilus/generator</code> is the program to generate some random test cases according to the grammar you define. If you give it the grammar we defined previously, a random string will be generated like the following if the grammar is correct. </p><div class="fragment"><div class="line">$ tools/nautilus/generator -g ./calc_grammar.json -t 100</div>
<div class="line">4/(((4)+1+7+7+5*4+1)-2-6+2-48-9*+5+52-6)</div>
<div class="line">$ tools/nautilus/generator -g ./calc_grammar.json -t 100</div>
<div class="line">45-((2))+8*-+9+2/4+7+4-(((3-6)/5)-2*9+(3)-7)</div>
</div><!-- fragment --><p>The following options are available, which you can also check by <code>--help</code> option.</p>
<ul>
<li><code>--grammar_path</code> / <code>-g</code>: Path to the grammar file [<b>Required</b>]</li>
<li><code>--tree_depth</code> / <code>-t</code>: Maximum size of tree (The bigger this value is, the longer the output will be) [<b>Required</b>]</li>
<li><code>--number_of_trees</code> / <code>-n</code>: Number of test cases to generate [Default:1]</li>
<li><code>--store</code> / <code>-s</code>: Path to the folder to save generated test cases in [Default:None]</li>
</ul>
<p>If your grammar file is invalid, it will dump an error. The following error message will be shown if JSON is invalid. </p><div class="fragment"><div class="line">[-] Cannot parse grammar file</div>
<div class="line">[json.exception.parse_error.101] parse error at line 3, column 5: syntax error while parsing array - unexpected &#39;[&#39;; expected &#39;]&#39;</div>
</div><!-- fragment --><p>In this case, the 3rd line of the grammar file has invalid JSON format.</p>
<p>A longer error like the following may also happen. </p><div class="fragment"><div class="line">Found unproductive rules: (missing base/non recursive case?)</div>
<div class="line">START =&gt; EXPRESSION</div>
<div class="line">EXPRESSION =&gt; TERM</div>
<div class="line">EXPRESSION =&gt; EXPRESSION, +, EXPRESSION</div>
<div class="line">EXPRESSION =&gt; EXPRESSION, -, EXPRESSION</div>
<div class="line">TERM =&gt; FACTOR</div>
<div class="line">TERM =&gt; FACTOR, *, FACTOR</div>
<div class="line">TERM =&gt; FACTOR, /, FACTOR</div>
<div class="line">FACTOR =&gt; NUMBER</div>
<div class="line">FACTOR =&gt; (, EXPRESSION, )</div>
<div class="line">NUMBER =&gt; FACTOR</div>
<div class="line">terminate called after throwing an instance of &#39;exceptions::fuzzuf_runtime_error&#39;</div>
<div class="line">  what():  Broken grammar</div>
</div><!-- fragment --><p>This error occurs if a non-terminal cannot reach the terminal. In the example above, <code>NUMBER =&gt; FACTOR</code> is invalid because it cannot reach the terminal by traversing <code>FACTOR</code>, which is an infinite loop. This error also shows up if an undefined non-terminal identifier (like a typo) appears.</p>
<p>You may encounter other errors like the following:</p>
<ul>
<li><code>Invalid rules (Rule must be array)</code>: The grammar is not a JSON array.</li>
<li><code>Invalid rule (Each rule must be a pair of string)</code>: Any of the non-terminal definition is not represented as a pair of strings. (This error will also show the invalid part of the JSON.)</li>
<li><code>Could not interpret Nonterminal {...}. Nonterminal Descriptions need to match start with a capital letter and can only contain [a-zA-Z_-0-9]</code>: A non-terminal identifier does not start with a capital letter, or contains invalid characters.</li>
</ul>
<p>Also, be careful that no error will happen if you forget to write brace for a non-terminal because it can be recognized as terminal characters. (Although, you will be able to find the error immediately by checking the test cases generated.) </p><div class="fragment"><div class="line">[&quot;EXPRESSION&quot;, &quot;{EXPRESSION}+{EXPRESSION&quot;]</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md160"></a>
2-3. Fuzzing</h2>
<p>Let's fuzz a calculator using the grammar we have written so far. At <code>test/put_binaries/nautilus/calc</code>, there exists a calculator instrumented by afl-gcc. This calculator prints the result of arithmetic calculation but it causes a crash when the result becomes a multiple of 314 except zero. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> res = express();</div>
<div class="line"><span class="keywordflow">if</span> (res != 0 &amp;&amp; res % 314 == 0) crash();</div>
</div><!-- fragment --><p>You have to instrument the target binary by AFL in Nautilus mode.</p>
<p>The Nautilus mode of fuzzuf provides the following options:</p>
<ul>
<li><code>--out_dir</code>, <code>-o</code>: Path to folder to save the fuzzing result [<b>Required</b>]</li>
<li><code>--exec_timelimit_ms</code>: Time limit of an execution (ms) [Default: 1000]</li>
<li><code>--exec_memlimit</code>: Memory limit of the target binary (MB) [Default: 0 (Unlimited)]</li>
<li><code>--grammar</code>: Path to grammar file [<b>Required</b>]</li>
<li><code>--bitmap-size</code>: Bitmap size [Default: 1&lt;&lt;16]</li>
<li><code>--generate-num</code>: The number of test cases generated in one fuzz loop [Default: 100]</li>
<li><code>--detmut-num</code>: Number of cycles to execute deterministic mutations [Default: 1]</li>
<li><code>--max-tree-size</code>: Maximum size of generated tree [Default: 1000]</li>
<li><code>--forksrv</code>: Enable/disable fork server mode. Default to true. (not recommended to disable)</li>
</ul>
<p>You can fuzz the calculator like this, for example: </p><div class="fragment"><div class="line">$ fuzzuf nautilus --out_dir output \</div>
<div class="line">                  --grammar ./calc_grammar.json \</div>
<div class="line">                  -- ./test/put_binaries/nautilus/calc @@</div>
</div><!-- fragment --><p>It is working successfully if a screen showing the status of fuzzing in real time appears.</p>
<p>If your usage or grammar file is wrong, an error will show up.</p>
<ul>
<li><code>Grammar does not exist!</code>: Grammar file specified by <code>--grammar</code> does not exist.</li>
<li>&lsquo;Unknown grammar type (&rsquo;.json' expected)<code>: The extension of grammar file is not ".json" -</code>Cannot parse grammar file`: The content of grammar file is wrong. (Check your grammar file as explained in section 2-2.)</li>
</ul>
<h1><a class="anchor" id="autotoc_md161"></a>
3. Algorithm</h1>
<p>Generally, grammar-based fuzzers generate AST (abstract syntax tree) according to a specific grammar and mutate a part of the AST to create testcases. Nautilus internally only uses the tree representation and mutates the tree. In this section, we explain the design of how Nautilus generates and mutates the testcases.</p>
<h2><a class="anchor" id="autotoc_md162"></a>
3-1. Generation</h2>
<p>Since a non-terminal may have multiple rules, we need an algorithm to decide which rule to pick up. Nautilus uses a uniform generation algorithm. Let's consider the following grammar: </p><div class="fragment"><div class="line">&lt;PROG&gt; := &lt;STMT&gt;</div>
<div class="line">&lt;PROG&gt; := &lt;STMT&gt;; &lt;PROG&gt;</div>
<div class="line">&lt;STMT&gt; := return 1</div>
<div class="line">&lt;STMT&gt; := &lt;VAR&gt; = &lt;EXPR&gt;</div>
<div class="line">&lt;VAR&gt;  := a</div>
<div class="line">&lt;EXPR&gt; := &lt;NUMBER&gt;</div>
<div class="line">&lt;EXPR&gt; := &lt;EXPR&gt; + &lt;EXPR&gt;</div>
<div class="line">&lt;NUMBER&gt; := 1</div>
<div class="line">&lt;NUMBER&gt; := 2</div>
</div><!-- fragment --><p>For example, <code>&lt;STMT&gt;</code> has 2 rules: <code>return 1</code> or <code>&lt;VAR&gt; = &lt;EXPR&gt;</code>. If we choose a rule for each non-terminal by naive randomness, <code>return 1</code> is chosen with 50% probability. On the other hand, if we choose <code>&lt;VAR&gt; = &lt;EXPR&gt;</code>, <code>&lt;EXPR&gt;</code> has another 2 rules: <code>&lt;NUMBER&gt;</code> and <code>&lt;EXPR&gt; + &lt;EXPR&gt;</code>. The probability that one of them is chosen is 25% from <code>&lt;STMT&gt;</code>. The deeper part of the tree is selected with less probability with naive randomness like this, which results in generating similar testcases. Nautilus, on the other hand, uses an algorithm by McKenzie[^2] so that it can select every rule in the grammar with the same probability.</p>
<h2><a class="anchor" id="autotoc_md163"></a>
3-2. Minimization</h2>
<p>Nautilus attempts to create a smaller testcase that triggers the same new coverage after it found an interesting input. Minimized inputs can make the execution time shorter and the number of set of potential mutations smaller. Nautilus uses two approaches to minimize the testcase that found new paths.</p>
<h3><a class="anchor" id="autotoc_md164"></a>
3-2-a. Subtree Minimization</h3>
<p><b>Subtree Minimization</b> is a process to make the subtree of AST as short as possible. We generate the smallest possible subtree for each non-terminal. Then, we replace the subtree of each node sequentially and check if we get the same coverage as that of the original tree. If we get the same coverage, the replaced tree is taken and otherwise, the change is discarded.</p>
<h3><a class="anchor" id="autotoc_md165"></a>
3-2-b. Recursive Minimization</h3>
<p><b>Recursive Minimization</b> is a process executed after the subtree minimization. This minimization replaces the nested part of AST. In the following figure, the statement <code>a = 1 + 2</code> is, for example, replaced into <code>a = 1</code>. </p><div class="fragment"><div class="line">   PROG                  PROG</div>
<div class="line">    |                     |</div>
<div class="line">   STMT                  STMT</div>
<div class="line">  / |  \                / |  \</div>
<div class="line">VAR = EXPR            VAR = EXPR</div>
<div class="line"> |    / | \     ----&gt;  |     |</div>
<div class="line"> a EXPR + EXPR         a    NUM</div>
<div class="line">    |      |                 |</div>
<div class="line">   NUM    NUM                1</div>
<div class="line">    |      |</div>
<div class="line">    1      2</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md166"></a>
3-3. Mutation</h2>
<p>After the minimization phase, Nautilus mutates the AST. Nautilus uses multiple mutation methods explained below.</p>
<h3><a class="anchor" id="autotoc_md167"></a>
3-3-a. Random Mutation</h3>
<p><b>Random Mutation</b> picks a random node from AST and replaces it with a randomly-generated new subtree whose root node shares the same non-terminal as the original one. The size of the subtree to be generated is also random but the maximum value is configured by <code>--max-tree-size</code> option.</p>
<h3><a class="anchor" id="autotoc_md168"></a>
3-3-b. Rules Mutation</h3>
<p><b>Rules Mutation</b> sequentially replaces each node of the AST with a new subtree generated by all other possible rules of the non-terminal. By replacing a node with a new rule, improvement of the coverage is expected as it uses a new grammar.</p>
<h3><a class="anchor" id="autotoc_md169"></a>
3-3-c. Random Recursive Mutation</h3>
<p><b>Random Recursive Mutation</b> randomly selects a recursive subtree and repeats it 2^n times (1≦n≦15). This mutation can create trees with higher degrees of nesting. The paper mentions 1≦n≦15 but the original Nautilus implementation uses 1≦n≦10 as the limit, so the fuzzuf also implements it with the latter bound.</p>
<h3><a class="anchor" id="autotoc_md170"></a>
3-3-d. Splicing Mutation</h3>
<p><b>Splicing Mutation</b> replaces a subtree of the testcase with a subtree taken from another testcase that found different paths. That is, splicing mutation combined two testcases.</p>
<h1><a class="anchor" id="autotoc_md171"></a>
4. Difference From the Original Implementation</h1>
<p>In this section, we explain some differences of the implementation between the Nautilus mode of fuzzuf and the original Nautilus.</p>
<h2><a class="anchor" id="autotoc_md172"></a>
4-1. ScriptRule and RegexpRule</h2>
<p>The original Nautilus implementation makes it possible to use Python and regular expressions in addition to JSON in order to write a grammar. Since those features are not necessarily required to define a grammar but require some external dependencies, we decided not to support those features in the first release of Nautilus mode.</p>
<h2><a class="anchor" id="autotoc_md173"></a>
4-2. ASAN</h2>
<p>The application does not send a signal on vulnerability detection when it is compiled with address sanitizers. Nautilus also checks the feedback of the sanitizers to catch the vulnerabilities detected by ASAN. However, the current Nautilus mode of fuzzuf does not support ASAN-instrumented program. This is because we're currently working on the revision of the Executors and so on. We will likely support sanitizers in the future releases.</p>
<h2><a class="anchor" id="autotoc_md174"></a>
4-3. AFL Mutations</h2>
<p>In addition to the mutation methods mentioned in this documentation, the original paper explains a mutation method named <b>AFL Mutations</b>. However, this mutation method is not implemented even in the original Nautilus. Therefore, the current Nautilus mode of fuzzuf also does not support this feature.</p>
<hr  />
<p>[^1]: Aschermann, Cornelius et al. “NAUTILUS: Fishing for Deep Bugs with Grammars.” Proceedings 2019 Network and Distributed System Security Symposium (2019): n. pag. [^2]: Bruce McKenzie. Generating strings at random from a context free grammar. 1997. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
