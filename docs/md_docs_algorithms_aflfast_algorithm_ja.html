<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fuzzuf: AFLFast</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fuzzuf
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">AFLFast </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md90"></a>
AFLFastとは</h1>
<p><a href="https://github.com/mboehme/aflfast">https://github.com/mboehme/aflfast</a></p>
<p>AFLFast[^ccs16]は、Michał Zalewskiによって開発された<a href="https://github.com/google/AFL">AFL</a>を拡張したファザーです。本稿で触れないAFLの基本的なアルゴリズムについてはAFL/algorithm_ja.mdを参照してください。 AFLFastを開発したMarcel Böhmeのチームは、AFLがあるシードから生成した入力のほとんどが同じパスを通り、興味深い挙動を示す他のパスはあまり通らないことを発見しました。これらの挙動を改善することによって、脆弱性に起因したバグを引き起こす入力をAFLのおよそ7倍高速に発見できるようになりました。AFLFastは、AFLの拡張として広く受け入れられており、AFLベースの研究のベースラインとして用いられていることからfuzzufでも実装されています。</p>
<h1><a class="anchor" id="autotoc_md91"></a>
CLI上での使用方法</h1>
<p>fuzzufではAFLFastはAFLと同様に使えます。次のようにして実行します。</p>
<div class="fragment"><div class="line">fuzzuf aflfast --in_dir=path/to/initial/seeds/ -- path/to/PUT @@</div>
</div><!-- fragment --><p>指定可能なグローバルなオプションはAFLと同様です。AFLのオプションについてはAFL/algorithm_ja.mdを参照してください。 なお、現時点ではAFLFast固有のローカルなオプションはなく、CLIでのスケジュールのオプションが未実装なため、CLIからはFASTのみが利用できます。</p>
<h1><a class="anchor" id="autotoc_md92"></a>
アルゴリズム概要</h1>
<p>AFLにおける問題点は、入力生成の効率にありました。あるパス <img src="https://render.githubusercontent.com/render/math?math=i" alt="i" class="inline"/> を実行するシードからパス <img src="https://render.githubusercontent.com/render/math?math=j" alt="j" class="inline"/> を実行する入力が発見されるためには、シードから生成される入力の数（以降エネルギーと呼びます）が重要な要素となります。エネルギーが大きすぎる場合は、最も効果的な手法であっても効率が悪いことが知られており[^tse15]、エネルギーが小さすぎる場合はそもそもパス <img src="https://render.githubusercontent.com/render/math?math=j" alt="j" class="inline"/> を実行する入力が発見できません。AFLでは、このエネルギーをシードのみから一意に決定できる式によって割り当てており、過不足が発生しています。</p>
<p>これに対し、AFLFastに実装されているFASTという手法はエネルギーを指数関数的に割り当てます。すなわち、あるシードが最初にファジングされたときはエネルギーが極めて低く、そのシードが選択されるたびにより多くのエネルギーが割り当てられ、生成される入力の数が増えていきます。このアルゴリズムによって、新しいパスを発見するのに必要なエネルギーをより効率的に発見することができるようになります。</p>
<h1><a class="anchor" id="autotoc_md93"></a>
パワースケジュールについて</h1>
<p>AFLFastで使用可能な <img src="https://render.githubusercontent.com/render/math?math=p(i)" alt="p(i)" class="inline"/> を計算するためのパワースケジュールは5種類あります。</p>
<h2><a class="anchor" id="autotoc_md94"></a>
EXPLOIT: exploitation-based constant schedule</h2>
<p>AFLを含むほとんどのグレーボックスファザーでは、実行時間やカバレッジ、生成時間からスコア <img src="https://render.githubusercontent.com/render/math?math=%5Calpha%28i%29" alt="\alpha(i)" class="inline"/> を計算し、エネルギーにはこの値をそのまま用います。</p>
<p><img src="https://render.githubusercontent.com/render/math?math=p%28i%29%20%3D%20%5Calpha%28i%29" alt="p(i) = \alpha(i)" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md95"></a>
EXPLORE: exploration-based constant schedule</h2>
<p>探索ベースのスケジュールはEXPLOITと同様に定数ですが、1以上の定数 <img src="https://render.githubusercontent.com/render/math?math=%5Cbeta" alt="\beta" class="inline"/> を用いて次の式で計算されます。</p>
<p><img src="https://render.githubusercontent.com/render/math?math=p%28i%29%20%3D%20%5Cfrac%7B%5Calpha%28i%29%7D%7B%5Cbeta%7D" alt="p(i) = \frac{\alpha(i)}{\beta}" class="inline"/></p>
<p>これは計算された <img src="https://render.githubusercontent.com/render/math?math=%5Calpha%28i%29" alt="\alpha(i)" class="inline"/> を採用しつつ、かなり低いエネルギーを割り当てます。</p>
<h2><a class="anchor" id="autotoc_md96"></a>
COE: Cut-Off Explonential</h2>
<p>カットオフ指数は高頻度のパスがファジングされるのを防ぎ、低頻度のパスになるまでファジングしないためのスケジュールです。 頻度の閾値 <img src="https://render.githubusercontent.com/render/math?math=%5Cmu" alt="\mu" class="inline"/> は発見されたパスの集合 <img src="https://render.githubusercontent.com/render/math?math=S%5E%7B%2B%7D" alt="S^{+}" class="inline"/> と <img src="https://render.githubusercontent.com/render/math?math=i" alt="i" class="inline"/> を通る入力の数 <img src="https://render.githubusercontent.com/render/math?math=f%28i%29" alt="f(i)" class="inline"/> を用いて、次の式によって定義されます。</p>
<p><img src="https://render.githubusercontent.com/render/math?math=%5Cmu%20%3D%20%5Cfrac%7B%5Csum_%7Bi%20%5Cin%20S%5E%7B%2B%7D%7D%20f%28i%29%7D%7B%7CS%5E%7B%2B%7D%7C%7D" alt="\mu = \frac{\sum_{i \in S^{+}} f(i)}{|S^{+}|}" class="inline"/></p>
<p><img src="https://render.githubusercontent.com/render/math?math=f%28i%29" alt="f(i)" class="inline"/> が <img src="https://render.githubusercontent.com/render/math?math=%5Cmu" alt="\mu" class="inline"/> より大きい場合は、他のシードをファジングしてもなお多くファジングされるとみなせるため優先度が低く設定され、再度 <img src="https://render.githubusercontent.com/render/math?math=%5Cmu" alt="\mu" class="inline"/> を下回るまで <img src="https://render.githubusercontent.com/render/math?math=p(i)" alt="p(i)" class="inline"/> が <img src="https://render.githubusercontent.com/render/math?math=0" alt="0" class="inline"/> に設定され、ファジングされません。</p>
<p><img src="https://render.githubusercontent.com/render/math?math=f%28i%29" alt="f(i)" class="inline"/> が <img src="https://render.githubusercontent.com/render/math?math=%5Cmu" alt="\mu" class="inline"/> 以下の場合、<img src="https://render.githubusercontent.com/render/math?math=p(i)" alt="p(i)" class="inline"/> は <img src="https://render.githubusercontent.com/render/math?math=s(i)" alt="s(i)" class="inline"/> （<img src="https://render.githubusercontent.com/render/math?math=t_i" alt="t_i" class="inline"/> が選ばれた回数）と <img src="https://render.githubusercontent.com/render/math?math=M" alt="M" class="inline"/> （ファジングのイテレーションごとに生成される入力値の数の上限）を用いて、次の式によって計算されます。</p>
<p><img src="https://render.githubusercontent.com/render/math?math=p%28i%29%20%3D%20%5Ctextrm%7Bmin%7D%5Cleft%28%5Cfrac%7B%5Calpha%28i%29%7D%7B%5Cbeta%7D%20%5Ccdot%202%5E%7Bs%28i%29%7D%2C%20M%5Cright%29" alt="p(i) = \textrm{min}\left(\frac{\alpha(i)}{\beta} \cdot 2^{s(i)}, M\right)" class="inline"/></p>
<p><img src="https://render.githubusercontent.com/render/math?math=%5Cfrac%7B%5Calpha%28i%29%7D%7B%5Cbeta%7D%20%3D%201" alt="\frac{\alpha(i)}{\beta} = 1" class="inline"/> におけるCOEスケジュールがクラッシュを見つけるまでの入力生成数は、AFLが256,000つだったのに対し4,000と、非常に効率的に入力を生成できることが実験的に判明しています。</p>
<h2><a class="anchor" id="autotoc_md97"></a>
FAST: exponential schedule</h2>
<p>COEを拡張した指数スケジュールでは、 <img src="https://render.githubusercontent.com/render/math?math=f%28i%29%20%3E%20%5Cmu" alt="f(i) > \mu" class="inline"/> の場合にファジングしないのではなく、 <img src="https://render.githubusercontent.com/render/math?math=f%28i%29" alt="f(i)" class="inline"/> に反比例した <img src="https://render.githubusercontent.com/render/math?math=p%28i%29" alt="p(i)" class="inline"/> を設定します。</p>
<p><img src="https://render.githubusercontent.com/render/math?math=p%28i%29%20%3D%20%5Ctextrm%7Bmin%7D%5Cleft%28%5Cfrac%7B%5Calpha%28i%29%7D%7B%5Cbeta%7D%20%5Ccdot%20%5Cfrac%7B2%5E%7Bs%28i%29%7D%7D%7Bf%28i%29%7D%20%2C%20M%5Cright%29" alt="p(i) = \textrm{min}\left(\frac{\alpha(i)}{\beta} \cdot \frac{2^{s(i)}}{f(i)} , M\right)" class="inline"/></p>
<p><img src="https://render.githubusercontent.com/render/math?math=f%28i%29" alt="f(i)" class="inline"/> を分母にすることで、ファジングされる頻度が少ないパスにいることが理由でファジングされなかったパスをファジングできるようになります。また指数的な増加をするので、ファジングされる頻度が少ないパスでも確実にファジングできるようになります。</p>
<h2><a class="anchor" id="autotoc_md98"></a>
LINEAR: linear schedule</h2>
<p>線形スケジュールは以下の式で表され、 <img src="https://render.githubusercontent.com/render/math?math=p%28i%29" alt="p(i)" class="inline"/> は指数的ではなく線形的に増加します。</p>
<p><img src="https://render.githubusercontent.com/render/math?math=p%28i%29%20%3D%20%5Ctextrm%7Bmin%7D%5Cleft%28%5Cfrac%7B%5Calpha%28i%29%7D%7B%5Cbeta%7D%20%5Ccdot%20%5Cfrac%7Bs%28i%29%7D%7Bf%28i%29%7D%2C%20M%5Cright%29" alt="p(i) = \textrm{min}\left(\frac{\alpha(i)}{\beta} \cdot \frac{s(i)}{f(i)}, M\right)" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md99"></a>
QUAD: quadratic schedule</h2>
<p>二次スケジュールは以下の式で表され、 <img src="https://render.githubusercontent.com/render/math?math=p%28i%29" alt="p(i)" class="inline"/> は二次関数的に増加します。</p>
<p><img src="https://render.githubusercontent.com/render/math?math=p%28i%29%20%3D%20%5Ctextrm%7Bmin%7D%5Cleft%28%5Cfrac%7B%5Calpha%28i%29%7D%7B%5Cbeta%7D%20%5Ccdot%20%5Cfrac%7Bs%28i%29%5E2%7D%7Bf%28i%29%7D%2C%20M%5Cright%29" alt="p(i) = \textrm{min}\left(\frac{\alpha(i)}{\beta} \cdot \frac{s(i)^2}{f(i)}, M\right)" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md100"></a>
参考文献</h1>
<p>[^ccs16]: Marcel Böhme, Van-Thuan Pham, and Abhik Roychoudhury. 2016. Coverage-based Greybox Fuzzing as Markov Chain. In Proceedings of the 23rd ACM Conference on Computer and Communications Security (CCS’16). [^tse15]: Marcel Bohme and Soumya Paul. 2015. A Probabilistic Analysis of the Efficiency of Automated Software Testing. In IEEE Transactions on Software Engineering (TSE'15). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
