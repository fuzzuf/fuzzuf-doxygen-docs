<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fuzzuf: libFuzzer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fuzzuf
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">libFuzzer </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md12337"></a>
What is libFuzzer?</h1>
<p><a href="https://llvm.org/docs/LibFuzzer.html">https://llvm.org/docs/LibFuzzer.html</a></p>
<p>libFuzzer is a greybox fuzzer provided as a part of the compiler-rt libraries of the LLVM project. We reimplemented it in fuzzuf because it is widely used and is the base of the current fuzzing research.</p>
<p>libFuzzer creates new input values by mutation based on the input values recorded in the corpus, executes a PUT with them, checks the coverage, and adds them to the corpus if rare paths are taken or if rare behaviors are observed. In this respect, libFuzzer is a fuzzer that is roughly similar to AFL but differs from AFL in the following points:</p>
<ul>
<li>Has a mutator that parses a random range of input values as if they were integers written in text, performs arithmetic operations on them, and then rewrites them back to their original positions (ChangeASCIIInt)</li>
<li>Has a mutator that takes two input values as arguments and randomly mixes them (Crossover).</li>
<li>A mutator that logs comparison operations using LLVM's <code>-fsanitize-coverage=trace-cmp</code>, and uses the values on both sides of the comparison as a dictionary (CMP)</li>
<li>Persistent Auto Dictionary automatically registers words in the dictionary when the fuzzer adds an input value created using the dictionary to the corpus.</li>
<li>If a new input value created after a given number of mutation runs (default 100) cannot get a new result for the corpus, the fuzzer will retry mutation on the same input value up to a specified number of times (default 5).</li>
<li>It is possible to specify that only a specific range of input values should be mutated (Mask).</li>
<li>In LLVM 10 and later, the fuzzer calculates how valuable an execution result value is (energy) by how many unusual paths the run took (feature). The energy affects the probability of an input value selection from the corpus (entropic scheduling). In LLVM 9 and earlier, the results of a run that find one or more new features are weighted (vanilla scheduling) so that the fuzzer choose the features found later features with a higher probability.</li>
<li>If the number of known features reaches the maximum number of feature types when the fuzzer finds a new feature, the features that commonly appear in the most number of executions (abundant features) will be ignored. Ignored features will no longer affect the calculation of energy. As a result, even if the fuzzer judged the result to be rare, its value will decrease if similar runs are found frequently and will be removed from the corpus when it becomes worthless (energy == 0).</li>
<li>If the fuzzer found a shorter input value that yields the same feature as the previous run, the corpus element is replaced by the shorter one (reduce).</li>
</ul>
<p>libFuzzer calls a function called harness with the new input value created by mutation as an argument. The user implements the harness that calls the function to be fuzzed using the input value generated by libFuzzer and links libFuzzer with the library that contains the target function. Such a fuzzing method has a performance advantage over the classical fuzzer implementation that spawns child processes (generating child processes is generally time-consuming).</p>
<p>Since the target and fuzzer are in the same process, the following problems occur.</p>
<ol type="1">
<li>The fuzzer should not count coverage of the fuzzer itself.</li>
<li>When the sanitizer reports a problem, it needs to distinguish whether it is reported by the fuzzing target or by the fuzzer itself.</li>
</ol>
<p>To support 1., libFuzzer will link the target built with <code>-fsanitize-coverage=edge</code> and the libFuzzer library built without <code>-fsanitize-coverage=edge</code>. It is carefully implemented so that inline functions in libFuzzer are not compiled during the build of the fuzzing target. On the other hand, it does not care that it counts the harness coverage.</p>
<p>To achieve 2., libFuzzer rewrites the information held by the sanitizer before and after executing the harness, if necessary. The implementation of LLVM's sanitizer is not an API that guarantees to be compatible in the future. Since libFuzzer itself is part of LLVM, it is implemented to be coupled with the corresponding version of LLVM's sanitizer.</p>
<p>As mentioned in the previous section on feature behavior, the original libFuzzer has some minor differences in behavior depending on the version. For example, up to LLVM 8, mt19937 is used as the random number generator, and after LLVM 9, minstd_rand is used.</p>
<h1><a class="anchor" id="autotoc_md12338"></a>
How libFuzzer works</h1>
<p>libFuzzer performs the process shown in the following pseudo-code.</p>
<p>Where <code>initial_input</code> is the initial seed, <code>target</code> is the fuzzing target, <code>total_count</code> is the number of times to execute the target, and <code>mutation_depth</code> is the number of times to perform mutation on the same input value.</p>
<div class="fragment"><div class="line">count = 0;</div>
<div class="line"><span class="comment">// Array of IDs of &quot;unique&quot; features that have appeared more than once but less frequently.</span></div>
<div class="line">unique_feature_set = {}</div>
<div class="line"><span class="comment">// A map holding the number of times a feature has appeared.</span></div>
<div class="line">global_feature_freqs = {}</div>
<div class="line">corpus = {}</div>
<div class="line"><span class="comment">// For all initial seeds:</span></div>
<div class="line"><span class="keywordflow">for</span>( input in initial_inputs ) {</div>
<div class="line">  <span class="comment">// Execute the target once.</span></div>
<div class="line">  exec_result = execute( target, input );</div>
<div class="line">  <span class="comment">// Add the execution result to the corpus.</span></div>
<div class="line">  add_to_corpus( corpus, exec_result, input );</div>
<div class="line">}</div>
<div class="line"><span class="comment">// Update the distribution of the probability of selecting the input value.</span></div>
<div class="line">dist = update_distribution( corpus );</div>
<div class="line"><span class="comment">// Until the number of attempts reaches total_count:</span></div>
<div class="line"><span class="keywordflow">while</span>( count &lt; total_count ) {</div>
<div class="line">  <span class="comment">// Until `i` reaches mutation_depth (default to 5 in libFuzzer):</span></div>
<div class="line">  <span class="keywordflow">for</span>( i = 0; i &lt; mutation_depth; ++i ) {</div>
<div class="line">    <span class="comment">// Select a input value from corpus.</span></div>
<div class="line">    [old_exec_result,input] = corpus.select_seed();</div>
<div class="line">    <span class="comment">// Perform mutation on the input value.</span></div>
<div class="line">    mut_input = mutate( dist, input );</div>
<div class="line">    <span class="comment">// Execute the target.</span></div>
<div class="line">    exec_result = execute( target, mut_input );</div>
<div class="line">    <span class="comment">// Collect the features from the execution result.</span></div>
<div class="line">    features = collect_features( old_exec_result, exec_result, unique_feature_set, global_feature_freqs );</div>
<div class="line">    <span class="comment">// If a new feature has been discovered:</span></div>
<div class="line">    <span class="keywordflow">if</span>( is_interesting( features ) ) {</div>
<div class="line">      <span class="comment">// Add the execution result and the input value to corpus.</span></div>
<div class="line">      corpus.add( exec_result, mut_input );</div>
<div class="line">      <span class="comment">// Update the distribution of the probability of selecting the input value.</span></div>
<div class="line">      dist = update_distribution( corpus );</div>
<div class="line">      <span class="comment">// Increment the attempt counter.</span></div>
<div class="line">      ++count;</div>
<div class="line">      <span class="comment">// Exit the loop if the execution result is added to corpus, even if `i` does not reach mutation_depth.</span></div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// Increment the attempt counter.</span></div>
<div class="line">      ++count;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>libFuzzer treats "features of interest" in the target execution results and gives them IDs. Features are the index of the edge in the edge coverage and the number of hits on the edge.</p>
<p>In the pseudo code above, <code>collect_features()</code> collects features from <code>exec_result</code> of the current seed execution. <code>collect_features()</code> updates <code>unique_feature_set</code> and <code>global_feature_freqs</code> each time a feature is found.</p>
<p>If there is a new feature in <code>features</code> collected by <code>collect_features()</code>, <code>corpus.add()</code> will add its execution result <code>exec_result</code> and the mutated input value <code>mut_input</code> to corpus. <code>is_interesting()</code> checks if <code>features</code> contains at least one "rare" feature from <code>unique_feature_set</code>. Finally, the probability <code>dist</code> of choosing the next input value is updated with <code>update_distribution()</code>.</p>
<p>There are two types of behavior of <code>update_distribution()</code>, vanilla scheduling and entropic scheduling, and the libFuzzer implementation of fuzzuf uses the former by default. In vanilla scheduling, libFuzzer uses a simple "select more recently found items with higher probability" policy. On the other hand, entropic scheduling evaluates the results of the seed runs and updates the probability distribution <code>dist</code> so that the results with higher evaluation are more likely to be selected in the next <code>select_seed()</code>. The evaluation value of the result of this seed run used in entropic scheduling is called energy, and the fuzzer calculates it while collecting features with <code>collect_features()</code> in the following terms:</p>
<ul>
<li>The number of "rare" features found.</li>
<li>The number of mutations performed from the initial seed to this input value.</li>
<li>How deviated from the average execution time is.</li>
</ul>
<p>In entropic scheduling, libFuzzer selects the seed according to the following policy by using energy:</p>
<ul>
<li>Focus on the input that produced the rarest features</li>
<li>Select inputs that have repeatedly found new features with each mutation.</li>
<li>Select inputs that run more quickly if the same number of features are found. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
