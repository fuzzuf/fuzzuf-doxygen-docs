<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fuzzuf: path-scurry</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fuzzuf
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">path-scurry </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Extremely high performant utility for building tools that read the file system, minimizing filesystem and path string munging operations to the greatest degree possible.</p>
<h1><a class="anchor" id="autotoc_md2349"></a>
Ugh, yet another file traversal thing on npm?</h1>
<p>Yes. None of the existing ones gave me exactly what I wanted.</p>
<h1><a class="anchor" id="autotoc_md2350"></a>
Well what is it you wanted?</h1>
<p>While working on <a href="http://npm.im/glob">glob</a>, I found that I needed a module to very efficiently manage the traversal over a folder tree, such that:</p>
<ol type="1">
<li>No <code>readdir()</code> or <code>stat()</code> would ever be called on the same file or directory more than one time.</li>
<li>No <code>readdir()</code> calls would be made if we can be reasonably sure that the path is not a directory. (Ie, a previous <code>readdir()</code> or <code>stat()</code> covered the path, and <code>ent.isDirectory()</code> is false.)</li>
<li><code>path.resolve()</code>, <code>dirname()</code>, <code>basename()</code>, and other string-parsing/munging operations are be minimized. This means it has to track "provisional" child nodes that may not exist (and if we find that they <em>don't</em> exist, store that information as well, so we don't have to ever check again).</li>
<li>The API is not limited to use as a stream/iterator/etc. There are many cases where an API like node's <code>fs</code> is preferrable.</li>
<li>It's more important to prevent excess syscalls than to be up to date, but it should be smart enough to know what it <em>doesn't</em> know, and go get it seamlessly when requested.</li>
<li>Do not blow up the JS heap allocation if operating on a directory with a huge number of entries.</li>
<li>Handle all the weird aspects of Windows paths, like UNC paths and drive letters and wrongway slashes, so that the consumer can return canonical platform-specific paths without having to parse or join or do any error-prone string munging.</li>
</ol>
<h1><a class="anchor" id="autotoc_md2351"></a>
PERFORMANCE</h1>
<p>JavaScript people throw around the word "blazing" a lot. I hope that this module doesn't blaze anyone. But it does go very fast, in the cases it's optimized for, if used properly.</p>
<p>PathScurry provides ample opportunities to get extremely good performance, as well as several options to trade performance for convenience.</p>
<p>Benchmarks can be run by executing <code>npm run bench</code>.</p>
<p>As is always the case, doing more means going slower, doing less means going faster, and there are trade offs between speed and memory usage.</p>
<p>PathScurry makes heavy use of <a href="http://npm.im/lru-cache">LRUCache</a> to efficiently cache whatever it can, and <code>Path</code> objects remain in the graph for the lifetime of the walker, so repeated calls with a single PathScurry object will be extremely fast. However, adding items to a cold cache means "doing more", so in those cases, we pay a price. Nothing is free, but every effort has been made to reduce costs wherever possible.</p>
<p>Also, note that a "cache as long as possible" approach means that changes to the filesystem may not be reflected in the results of repeated PathScurry operations.</p>
<p>For resolving string paths, <code>PathScurry</code> ranges from 5-50 times faster than <code>path.resolve</code> on repeated resolutions, but around 100 to 1000 times <em>slower</em> on the first resolution. If your program is spending a lot of time resolving the <em>same</em> paths repeatedly (like, thousands or millions of times), then this can be beneficial. But both implementations are pretty fast, and speeding up an infrequent operation from 4Âµs to 400ns is not going to move the needle on your app's performance.</p>
<p>For walking file system directory trees, a lot depends on how often a given PathScurry object will be used, and also on the walk method used.</p>
<p>With default settings on a folder tree of 100,000 items, consisting of around a 10-to-1 ratio of normal files to directories, PathScurry performs comparably to <a href="http://npm.im/@nodelib/fs.walk">@nodelib/fs.walk</a>, which is the fastest and most reliable file system walker I could find. As far as I can tell, it's almost impossible to go much faster in a Node.js program, just based on how fast you can push syscalls out to the fs thread pool.</p>
<p>On my machine, that is about 1000-1200 completed walks per second for async or stream walks, and around 500-600 walks per second synchronously.</p>
<p>In the warm cache state, PathScurry's performance increases around 4x for async <code>for await</code> iteration, 10-15x faster for streams and synchronous <code>for of</code> iteration, and anywhere from 30x to 80x faster for the rest.</p>
<div class="fragment"><div class="line"># walk 100,000 fs entries, 10/1 file/dir ratio</div>
<div class="line"># operations / ms</div>
<div class="line"> New PathScurry object  |  Reuse PathScurry object</div>
<div class="line">     stream:  1112.589  |  13974.917</div>
<div class="line">sync stream:   492.718  |  15028.343</div>
<div class="line"> async walk:  1095.648  |  32706.395</div>
<div class="line">  sync walk:   527.632  |  46129.772</div>
<div class="line"> async iter:  1288.821  |   5045.510</div>
<div class="line">  sync iter:   498.496  |  17920.746</div>
</div><!-- fragment --><p>A hand-rolled walk calling <code>entry.readdir()</code> and recursing through the entries can benefit even more from caching, with greater flexibility and without the overhead of streams or generators.</p>
<p>The cold cache state is still limited by the costs of file system operations, but with a warm cache, the only bottleneck is CPU speed and VM optimizations. Of course, in that case, some care must be taken to ensure that you don't lose performance as a result of silly mistakes, like calling <code>readdir()</code> on entries that you know are not directories.</p>
<div class="fragment"><div class="line"># manual recursive iteration functions</div>
<div class="line">      cold cache  |  warm cache</div>
<div class="line">async:  1164.901  |  17923.320</div>
<div class="line">   cb:  1101.127  |  40999.344</div>
<div class="line">zalgo:  1082.240  |  66689.936</div>
<div class="line"> sync:   526.935  |  87097.591</div>
</div><!-- fragment --><p>In this case, the speed improves by around 10-20x in the async case, 40x in the case of using <code>entry.readdirCB</code> with protections against synchronous callbacks, and 50-100x with callback deferrals disabled, and <em>several hundred times faster</em> for synchronous iteration.</p>
<p>If you can think of a case that is not covered in these benchmarks, or an implementation that performs significantly better than PathScurry, please <a href="https://github.com/isaacs/path-scurry/issues">let me know</a>.</p>
<h1><a class="anchor" id="autotoc_md2352"></a>
USAGE</h1>
<div class="fragment"><div class="line">// hybrid module, load with either method</div>
<div class="line">import { PathScurry, Path } from &#39;path-scurry&#39;</div>
<div class="line">// or:</div>
<div class="line">const { PathScurry, Path } = require(&#39;path-scurry&#39;)</div>
<div class="line"> </div>
<div class="line">// very simple example, say we want to find and</div>
<div class="line">// delete all the .DS_Store files in a given path</div>
<div class="line">// note that the API is very similar to just a</div>
<div class="line">// naive walk with fs.readdir()</div>
<div class="line">import { unlink } from &#39;fs/promises&#39;</div>
<div class="line"> </div>
<div class="line">// easy way, iterate over the directory and do the thing</div>
<div class="line">const pw = new PathScurry(process.cwd())</div>
<div class="line">for await (const entry of pw) {</div>
<div class="line">  if (entry.isFile() &amp;&amp; entry.name === &#39;.DS_Store&#39;) {</div>
<div class="line">    unlink(entry.fullpath())</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// here it is as a manual recursive method</div>
<div class="line">const walk = async (entry: Path) =&gt; {</div>
<div class="line">  const promises: Promise&lt;any&gt; = []</div>
<div class="line">  // readdir doesn&#39;t throw on non-directories, it just doesn&#39;t</div>
<div class="line">  // return any entries, to save stack trace costs.</div>
<div class="line">  // Items are returned in arbitrary unsorted order</div>
<div class="line">  for (const child of await pw.readdir(entry)) {</div>
<div class="line">    // each child is a Path object</div>
<div class="line">    if (child.name === &#39;.DS_Store&#39; &amp;&amp; child.isFile()) {</div>
<div class="line">      // could also do pw.resolve(entry, child.name),</div>
<div class="line">      // just like fs.readdir walking, but .fullpath is</div>
<div class="line">      // a *slightly* more efficient shorthand.</div>
<div class="line">      promises.push(unlink(child.fullpath()))</div>
<div class="line">    } else if (child.isDirectory()) {</div>
<div class="line">      promises.push(walk(child))</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  return Promise.all(promises)</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">walk(pw.cwd).then(() =&gt; {</div>
<div class="line">  console.log(&#39;all .DS_Store files removed&#39;)</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">const pw2 = new PathScurry(&#39;/a/b/c&#39;) // pw2.cwd is the Path for /a/b/c</div>
<div class="line">const relativeDir = pw2.cwd.resolve(&#39;../x&#39;) // Path entry for &#39;/a/b/x&#39;</div>
<div class="line">const relative2 = pw2.cwd.resolve(&#39;/a/b/d/../x&#39;) // same path, same entry</div>
<div class="line">assert.equal(relativeDir, relative2)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md2353"></a>
API</h1>
<p><a href="https://isaacs.github.io/path-scurry">Full TypeDoc API</a></p>
<p>There are platform-specific classes exported, but for the most part, the default <code>PathScurry</code> and <code>Path</code> exports are what you most likely need, unless you are testing behavior for other platforms.</p>
<p>Intended public API is documented here, but the full documentation does include internal types, which should not be accessed directly.</p>
<h2><a class="anchor" id="autotoc_md2354"></a>
Interface &lt;tt&gt;PathScurryOpts&lt;/tt&gt;</h2>
<p>The type of the <code>options</code> argument passed to the <code>PathScurry</code> constructor.</p>
<ul>
<li><p class="startli"><code>nocase</code>: Boolean indicating that file names should be compared case-insensitively. Defaults to <code>true</code> on darwin and win32 implementations, <code>false</code> elsewhere.</p>
<p class="startli"><b>Warning</b> Performing case-insensitive matching on a case-sensitive filesystem will result in occasionally very bizarre behavior. Performing case-sensitive matching on a case-insensitive filesystem may negatively impact performance.</p>
</li>
<li><p class="startli"><code>childrenCacheSize</code>: Number of child entries to cache, in order to speed up <code>resolve()</code> and <code>readdir()</code> calls. Defaults to <code>16 * 1024</code> (ie, <code>16384</code>).</p>
<p class="startli">Setting it to a higher value will run the risk of JS heap allocation errors on large directory trees. Setting it to <code>256</code> or smaller will significantly reduce the construction time and data consumption overhead, but with the downside of operations being slower on large directory trees. Setting it to <code>0</code> will mean that effectively no operations are cached, and this module will be roughly the same speed as <code>fs</code> for file system operations, and <em>much</em> slower than <code>path.resolve()</code> for repeated path resolution.</p>
</li>
<li><code>fs</code> An object that will be used to override the default <code>fs</code> methods. Any methods that are not overridden will use Node's built-in implementations.<ul>
<li>lstatSync</li>
<li>readdir (callback <code>withFileTypes</code> Dirent variant, used for readdirCB and most walks)</li>
<li>readdirSync</li>
<li>readlinkSync</li>
<li>realpathSync</li>
<li>promises: Object containing the following async methods:<ul>
<li>lstat</li>
<li>readdir (Dirent variant only)</li>
<li>readlink</li>
<li>realpath</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md2355"></a>
Interface &lt;tt&gt;WalkOptions&lt;/tt&gt;</h2>
<p>The options object that may be passed to all walk methods.</p>
<ul>
<li><code>withFileTypes</code>: Boolean, default true. Indicates that <code>Path</code> objects should be returned. Set to <code>false</code> to get string paths instead.</li>
<li><p class="startli"><code>follow</code>: Boolean, default false. Attempt to read directory entries from symbolic links. Otherwise, only actual directories are traversed. Regardless of this setting, a given target path will only ever be walked once, meaning that a symbolic link to a previously traversed directory will never be followed.</p>
<p class="startli">Setting this imposes a slight performance penalty, because <code>readlink</code> must be called on all symbolic links encountered, in order to avoid infinite cycles.</p>
</li>
<li><code>filter</code>: Function <code>(entry: Path) =&gt; boolean</code>. If provided, will prevent the inclusion of any entry for which it returns a falsey value. This will not prevent directories from being traversed if they do not pass the filter, though it will prevent the directories themselves from being included in the results. By default, if no filter is provided, then all entries are included in the results.</li>
<li><code>walkFilter</code>: Function <code>(entry: Path) =&gt; boolean</code>. If provided, will prevent the traversal of any directory (or in the case of <code>follow:true</code> symbolic links to directories) for which the function returns false. This will not prevent the directories themselves from being included in the result set. Use <code>filter</code> for that.</li>
</ul>
<p>Note that TypeScript return types will only be inferred properly from static analysis if the <code>withFileTypes</code> option is omitted, or a constant <code>true</code> or <code>false</code> value.</p>
<h2><a class="anchor" id="autotoc_md2356"></a>
Class &lt;tt&gt;PathScurry&lt;/tt&gt;</h2>
<p>The main interface. Defaults to an appropriate class based on the current platform.</p>
<p>Use <code>PathScurryWin32</code>, <code>PathScurryDarwin</code>, or <code>PathScurryPosix</code> if implementation-specific behavior is desired.</p>
<p>All walk methods may be called with a <code>WalkOptions</code> argument to walk over the object's current working directory with the supplied options.</p>
<h3><a class="anchor" id="autotoc_md2357"></a>
&lt;tt&gt;async pw.walk(entry?: string | Path | WalkOptions, opts?: WalkOptions)&lt;/tt&gt;</h3>
<p>Walk the directory tree according to the options provided, resolving to an array of all entries found.</p>
<h3><a class="anchor" id="autotoc_md2358"></a>
&lt;tt&gt;pw.walkSync(entry?: string | Path | WalkOptions, opts?: WalkOptions)&lt;/tt&gt;</h3>
<p>Walk the directory tree according to the options provided, returning an array of all entries found.</p>
<h3><a class="anchor" id="autotoc_md2359"></a>
&lt;tt&gt;pw.iterate(entry?: string | Path | WalkOptions, opts?: WalkOptions)&lt;/tt&gt;</h3>
<p>Iterate over the directory asynchronously, for use with <code>for await of</code>. This is also the default async iterator method.</p>
<h3><a class="anchor" id="autotoc_md2360"></a>
&lt;tt&gt;pw.iterateSync(entry?: string | Path | WalkOptions, opts?: WalkOptions)&lt;/tt&gt;</h3>
<p>Iterate over the directory synchronously, for use with <code>for of</code>. This is also the default sync iterator method.</p>
<h3><a class="anchor" id="autotoc_md2361"></a>
&lt;tt&gt;pw.stream(entry?: string | Path | WalkOptions, opts?: WalkOptions)&lt;/tt&gt;</h3>
<p>Return a <a href="http://npm.im/minipass">Minipass</a> stream that emits each entry or path string in the walk. Results are made available asynchronously.</p>
<h3><a class="anchor" id="autotoc_md2362"></a>
&lt;tt&gt;pw.streamSync(entry?: string | Path | WalkOptions, opts?: WalkOptions)&lt;/tt&gt;</h3>
<p>Return a <a href="http://npm.im/minipass">Minipass</a> stream that emits each entry or path string in the walk. Results are made available synchronously, meaning that the walk will complete in a single tick if the stream is fully consumed.</p>
<h3><a class="anchor" id="autotoc_md2363"></a>
&lt;tt&gt;pw.cwd&lt;/tt&gt;</h3>
<p>Path object representing the current working directory for the PathScurry.</p>
<h3><a class="anchor" id="autotoc_md2364"></a>
&lt;tt&gt;pw.chdir(path: string)&lt;/tt&gt;</h3>
<p>Set the new effective current working directory for the scurry object, so that <code>path.relative()</code> and <code>path.relativePosix()</code> return values relative to the new cwd path.</p>
<h3><a class="anchor" id="autotoc_md2365"></a>
&lt;tt&gt;pw.depth(path?: Path | string): number&lt;/tt&gt;</h3>
<p>Return the depth of the specified path (or the PathScurry cwd) within the directory tree.</p>
<p>Root entries have a depth of <code>0</code>.</p>
<h3><a class="anchor" id="autotoc_md2366"></a>
&lt;tt&gt;pw.resolve(...paths: string[])&lt;/tt&gt;</h3>
<p>Caching <code>path.resolve()</code>.</p>
<p>Significantly faster than <code>path.resolve()</code> if called repeatedly with the same paths. Significantly slower otherwise, as it builds out the cached Path entries.</p>
<p>To get a <code>Path</code> object resolved from the <code>PathScurry</code>, use <code>pw.cwd.resolve(path)</code>. Note that <code>Path.resolve</code> only takes a single string argument, not multiple.</p>
<h3><a class="anchor" id="autotoc_md2367"></a>
&lt;tt&gt;pw.resolvePosix(...paths: string[])&lt;/tt&gt;</h3>
<p>Caching <code>path.resolve()</code>, but always using posix style paths.</p>
<p>This is identical to <code>pw.resolve(...paths)</code> on posix systems (ie, everywhere except Windows).</p>
<p>On Windows, it returns the full absolute UNC path using <code>/</code> separators. Ie, instead of <code>'C:\\foo\\bar</code>, it would return <code>//?/C:/foo/bar</code>.</p>
<h3><a class="anchor" id="autotoc_md2368"></a>
&lt;tt&gt;pw.relative(path: string | Path): string&lt;/tt&gt;</h3>
<p>Return the relative path from the PathWalker cwd to the supplied path string or entry.</p>
<p>If the nearest common ancestor is the root, then an absolute path is returned.</p>
<h3><a class="anchor" id="autotoc_md2369"></a>
&lt;tt&gt;pw.relativePosix(path: string | Path): string&lt;/tt&gt;</h3>
<p>Return the relative path from the PathWalker cwd to the supplied path string or entry, using <code>/</code> path separators.</p>
<p>If the nearest common ancestor is the root, then an absolute path is returned.</p>
<p>On posix platforms (ie, all platforms except Windows), this is identical to <code>pw.relative(path)</code>.</p>
<p>On Windows systems, it returns the resulting string as a <code>/</code>-delimited path. If an absolute path is returned (because the target does not share a common ancestor with <code>pw.cwd</code>), then a full absolute UNC path will be returned. Ie, instead of <code>'C:\\foo\\bar</code>, it would return <code>//?/C:/foo/bar</code>.</p>
<h3><a class="anchor" id="autotoc_md2370"></a>
&lt;tt&gt;pw.basename(path: string | Path): string&lt;/tt&gt;</h3>
<p>Return the basename of the provided string or Path.</p>
<h3><a class="anchor" id="autotoc_md2371"></a>
&lt;tt&gt;pw.dirname(path: string | Path): string&lt;/tt&gt;</h3>
<p>Return the parent directory of the supplied string or Path.</p>
<h3><a class="anchor" id="autotoc_md2372"></a>
&lt;tt&gt;async pw.readdir(dir = pw.cwd, opts = { withFileTypes: true })&lt;/tt&gt;</h3>
<p>Read the directory and resolve to an array of strings if <code>withFileTypes</code> is explicitly set to <code>false</code> or Path objects otherwise.</p>
<p>Can be called as <code>pw.readdir({ withFileTypes: boolean })</code> as well.</p>
<p>Returns <code>[]</code> if no entries are found, or if any error occurs.</p>
<p>Note that TypeScript return types will only be inferred properly from static analysis if the <code>withFileTypes</code> option is omitted, or a constant <code>true</code> or <code>false</code> value.</p>
<h3><a class="anchor" id="autotoc_md2373"></a>
&lt;tt&gt;pw.readdirSync(dir = pw.cwd, opts = { withFileTypes: true })&lt;/tt&gt;</h3>
<p>Synchronous <code>pw.readdir()</code></p>
<h3><a class="anchor" id="autotoc_md2374"></a>
&lt;tt&gt;async pw.readlink(link = pw.cwd, opts = { withFileTypes: false })&lt;/tt&gt;</h3>
<p>Call <code>fs.readlink</code> on the supplied string or Path object, and return the result.</p>
<p>Can be called as <code>pw.readlink({ withFileTypes: boolean })</code> as well.</p>
<p>Returns <code>undefined</code> if any error occurs (for example, if the argument is not a symbolic link), or a <code>Path</code> object if <code>withFileTypes</code> is explicitly set to <code>true</code>, or a string otherwise.</p>
<p>Note that TypeScript return types will only be inferred properly from static analysis if the <code>withFileTypes</code> option is omitted, or a constant <code>true</code> or <code>false</code> value.</p>
<h3><a class="anchor" id="autotoc_md2375"></a>
&lt;tt&gt;pw.readlinkSync(link = pw.cwd, opts = { withFileTypes: false })&lt;/tt&gt;</h3>
<p>Synchronous <code>pw.readlink()</code></p>
<h3><a class="anchor" id="autotoc_md2376"></a>
&lt;tt&gt;async pw.lstat(entry = pw.cwd)&lt;/tt&gt;</h3>
<p>Call <code>fs.lstat</code> on the supplied string or Path object, and fill in as much information as possible, returning the updated <code>Path</code> object.</p>
<p>Returns <code>undefined</code> if the entry does not exist, or if any error is encountered.</p>
<p>Note that some <code>Stats</code> data (such as <code>ino</code>, <code>dev</code>, and <code>mode</code>) will not be supplied. For those things, you'll need to call <code>fs.lstat</code> yourself.</p>
<h3><a class="anchor" id="autotoc_md2377"></a>
&lt;tt&gt;pw.lstatSync(entry = pw.cwd)&lt;/tt&gt;</h3>
<p>Synchronous <code>pw.lstat()</code></p>
<h3><a class="anchor" id="autotoc_md2378"></a>
&lt;tt&gt;pw.realpath(entry = pw.cwd, opts = { withFileTypes: false })&lt;/tt&gt;</h3>
<p>Call <code>fs.realpath</code> on the supplied string or Path object, and return the realpath if available.</p>
<p>Returns <code>undefined</code> if any error occurs.</p>
<p>May be called as <code>pw.realpath({ withFileTypes: boolean })</code> to run on <code>pw.cwd</code>.</p>
<h3><a class="anchor" id="autotoc_md2379"></a>
&lt;tt&gt;pw.realpathSync(entry = pw.cwd, opts = { withFileTypes: false })&lt;/tt&gt;</h3>
<p>Synchronous <code>pw.realpath()</code></p>
<h2><a class="anchor" id="autotoc_md2380"></a>
Class &lt;tt&gt;Path&lt;/tt&gt; implements &lt;a href="https://nodejs.org/docs/latest/api/fs.html#class-fsdirent"&gt;fs.Dirent&lt;/a&gt;</h2>
<p>Object representing a given path on the filesystem, which may or may not exist.</p>
<p>Note that the actual class in use will be either <code>PathWin32</code> or <code>PathPosix</code>, depending on the implementation of <code>PathScurry</code> in use. They differ in the separators used to split and join path strings, and the handling of root paths.</p>
<p>In <code>PathPosix</code> implementations, paths are split and joined using the &lsquo;&rsquo;/'<code>character, and</code>'/'` is the only root path ever in use.</p>
<p>In <code>PathWin32</code> implementations, paths are split using either &lsquo;&rsquo;/'<code>or</code>'\'<code>and joined using</code>'\'`, and multiple roots may be in use based on the drives and UNC paths encountered. UNC paths such as <code>//?/C:/</code> that identify a drive letter, will be treated as an alias for the same root entry as their associated drive letter (in this case &lsquo;'C:\&rsquo;`).</p>
<h3><a class="anchor" id="autotoc_md2381"></a>
&lt;tt&gt;path.name&lt;/tt&gt;</h3>
<p>Name of this file system entry.</p>
<p><b>Important</b>: <em>always</em> test the path name against any test string using the <code>isNamed</code> method, and not by directly comparing this string. Otherwise, unicode path strings that the system sees as identical will not be properly treated as the same path, leading to incorrect behavior and possible security issues.</p>
<h3><a class="anchor" id="autotoc_md2382"></a>
&lt;tt&gt;path.isNamed(name: string): boolean&lt;/tt&gt;</h3>
<p>Return true if the path is a match for the given path name. This handles case sensitivity and unicode normalization.</p>
<p>Note: even on case-sensitive systems, it is <b>not</b> safe to test the equality of the <code>.name</code> property to determine whether a given pathname matches, due to unicode normalization mismatches.</p>
<p>Always use this method instead of testing the <code>path.name</code> property directly.</p>
<h3><a class="anchor" id="autotoc_md2383"></a>
&lt;tt&gt;path.getType()&lt;/tt&gt;</h3>
<p>Returns the type of the Path object, &lsquo;'File&rsquo;<code>,</code>'Directory'`, etc.</p>
<h3><a class="anchor" id="autotoc_md2384"></a>
&lt;tt&gt;path.isType(t: type)&lt;/tt&gt;</h3>
<p>Returns true if <code>is{t}()</code> returns true.</p>
<p>For example, &lsquo;path.isType('Directory&rsquo;)<code>is equivalent to </code>path.isDirectory()`.</p>
<h3><a class="anchor" id="autotoc_md2385"></a>
&lt;tt&gt;path.depth()&lt;/tt&gt;</h3>
<p>Return the depth of the Path entry within the directory tree. Root paths have a depth of <code>0</code>.</p>
<h3><a class="anchor" id="autotoc_md2386"></a>
&lt;tt&gt;path.fullpath()&lt;/tt&gt;</h3>
<p>The fully resolved path to the entry.</p>
<h3><a class="anchor" id="autotoc_md2387"></a>
&lt;tt&gt;path.fullpathPosix()&lt;/tt&gt;</h3>
<p>The fully resolved path to the entry, using <code>/</code> separators.</p>
<p>On posix systems, this is identical to <code>path.fullpath()</code>. On windows, this will return a fully resolved absolute UNC path using <code>/</code> separators. Eg, instead of &lsquo;'C:\foo\bar&rsquo;<code>, it will return</code>'//?/C:/foo/bar'`.</p>
<h3><a class="anchor" id="autotoc_md2388"></a>
&lt;tt&gt;path.isFile()&lt;/tt&gt;, &lt;tt&gt;path.isDirectory()&lt;/tt&gt;, etc.</h3>
<p>Same as the identical <code>fs.Dirent.isX()</code> methods.</p>
<h3><a class="anchor" id="autotoc_md2389"></a>
&lt;tt&gt;path.isUnknown()&lt;/tt&gt;</h3>
<p>Returns true if the path's type is unknown. Always returns true when the path is known to not exist.</p>
<h3><a class="anchor" id="autotoc_md2390"></a>
&lt;tt&gt;path.resolve(p: string)&lt;/tt&gt;</h3>
<p>Return a <code>Path</code> object associated with the provided path string as resolved from the current Path object.</p>
<h3><a class="anchor" id="autotoc_md2391"></a>
&lt;tt&gt;path.relative(): string&lt;/tt&gt;</h3>
<p>Return the relative path from the PathWalker cwd to the supplied path string or entry.</p>
<p>If the nearest common ancestor is the root, then an absolute path is returned.</p>
<h3><a class="anchor" id="autotoc_md2392"></a>
&lt;tt&gt;path.relativePosix(): string&lt;/tt&gt;</h3>
<p>Return the relative path from the PathWalker cwd to the supplied path string or entry, using <code>/</code> path separators.</p>
<p>If the nearest common ancestor is the root, then an absolute path is returned.</p>
<p>On posix platforms (ie, all platforms except Windows), this is identical to <code>pw.relative(path)</code>.</p>
<p>On Windows systems, it returns the resulting string as a <code>/</code>-delimited path. If an absolute path is returned (because the target does not share a common ancestor with <code>pw.cwd</code>), then a full absolute UNC path will be returned. Ie, instead of <code>'C:\\foo\\bar</code>, it would return <code>//?/C:/foo/bar</code>.</p>
<h3><a class="anchor" id="autotoc_md2393"></a>
&lt;tt&gt;async path.readdir()&lt;/tt&gt;</h3>
<p>Return an array of <code>Path</code> objects found by reading the associated path entry.</p>
<p>If path is not a directory, or if any error occurs, returns <code>[]</code>, and marks all children as provisional and non-existent.</p>
<h3><a class="anchor" id="autotoc_md2394"></a>
&lt;tt&gt;path.readdirSync()&lt;/tt&gt;</h3>
<p>Synchronous <code>path.readdir()</code></p>
<h3><a class="anchor" id="autotoc_md2395"></a>
&lt;tt&gt;async path.readlink()&lt;/tt&gt;</h3>
<p>Return the <code>Path</code> object referenced by the <code>path</code> as a symbolic link.</p>
<p>If the <code>path</code> is not a symbolic link, or any error occurs, returns <code>undefined</code>.</p>
<h3><a class="anchor" id="autotoc_md2396"></a>
&lt;tt&gt;path.readlinkSync()&lt;/tt&gt;</h3>
<p>Synchronous <code>path.readlink()</code></p>
<h3><a class="anchor" id="autotoc_md2397"></a>
&lt;tt&gt;async path.lstat()&lt;/tt&gt;</h3>
<p>Call <code>lstat</code> on the path object, and fill it in with details determined.</p>
<p>If path does not exist, or any other error occurs, returns <code>undefined</code>, and marks the path as "unknown" type.</p>
<h3><a class="anchor" id="autotoc_md2398"></a>
&lt;tt&gt;path.lstatSync()&lt;/tt&gt;</h3>
<p>Synchronous <code>path.lstat()</code></p>
<h3><a class="anchor" id="autotoc_md2399"></a>
&lt;tt&gt;async path.realpath()&lt;/tt&gt;</h3>
<p>Call <code>realpath</code> on the path, and return a Path object corresponding to the result, or <code>undefined</code> if any error occurs.</p>
<h3><a class="anchor" id="autotoc_md2400"></a>
&lt;tt&gt;path.realpathSync()&lt;/tt&gt;</h3>
<p>Synchornous <code>path.realpath()</code> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
