<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fuzzuf: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fuzzuf
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>#Introduction</p>
<p>Extremely fast <a href="http://en.wikipedia.org/wiki/Double-ended_queue">double-ended queue</a> implementation. Double-ended queue can also be used as a:</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Stack_\(abstract_data_type\)">Stack</a></li>
<li><a href="http://en.wikipedia.org/wiki/Queue_\(data_structure\)">Queue</a></li>
</ul>
<p>The implementation is GC and CPU cache friendly <a href="http://en.wikipedia.org/wiki/Circular_buffer">circular buffer</a>. <a href="#performance">It will run circles around any "linked list" implementation</a>.</p>
<p>Every queue operation is done in constant <code>O(1)</code> - including random access from <code>.get()</code>.</p>
<p>#Topics</p>
<ul>
<li><a href="#quick-start">Quick start</a></li>
<li><a href="#why-not-use-an-array">Why not use an Array?</a></li>
<li><a href="#using-double-ended-queue-as-a-normal-queue">Using double-ended queue as a normal queue</a></li>
<li><a href="#api">API reference and examples</a></li>
<li><a href="#performance">Performance</a></li>
</ul>
<p>#Quick start </p><pre class="fragment">npm install double-ended-queue
</pre><div class="fragment"><div class="line">var Deque = require(&quot;double-ended-queue&quot;);</div>
<div class="line"> </div>
<div class="line">var deque = new Deque([1,2,3,4]);</div>
<div class="line">deque.shift(); //1</div>
<div class="line">deque.pop(); //4</div>
</div><!-- fragment --><p>#Why not use an Array?</p>
<p>Arrays take linear <code>O(N)</code> time to do <code>shift</code> and <code>unshift</code> operations. That means in theory that an array with 1000 items is 1000x slower to do those operations than a deque with 1000 items. 10000x slower with 10000 items and so on.</p>
<p>V8 implements <a href="https://code.google.com/p/v8/issues/detail?id=3059">a trick for small arrays</a> where these operations are done in constant time, however even with this trick deque is still 4x faster.</p>
<p>But arrays use "native" methods, they must be faster!</p>
<p>In V8, there is almost no advantage for a method to be a built-in. In fact many times built-ins are at a severe disadvantage of having to implement far more complex semantics than is actually needed in practice. For example, sparse array handling punishes almost every built-in array method even though nobody uses sparse arrays as is evidenced by the popularity of the underscore library which doesn't handle sparse arrays in the same way across different browsers.</p>
<p>#Using double-ended queue as a normal queue</p>
<p>Queue is a more commonly needed data structure however a separate implementation does not provide any advantage in terms of performance. Aliases are provided specifically for the queue use-case. You may use <code>.enqueue(items...)</code> to enqueue item(s) and <code>.dequeue()</code> to dequeue an item.</p>
<p>#API</p>
<ul>
<li><a href="#new-deque---deque"><code>new Deque()</code></a></li>
<li><a href="#new-dequearray-items---deque"><code>new Deque(Array items)</code></a></li>
<li><a href="#new-dequeint-capacity---deque"><code>new Deque(int capacity)</code></a></li>
<li><a href="#pushdynamic-items---int"><code>push(dynamic items...)</code></a></li>
<li><a href="#unshiftdynamic-items---int"><code>unshift(dynamic items...)</code></a></li>
<li><a href="#pop---dynamic"><code>pop()</code></a></li>
<li><a href="#shift---dynamic"><code>shift()</code></a></li>
<li><a href="#toarray---array"><code>toArray()</code></a></li>
<li><a href="#peekback---dynamic"><code>peekBack()</code></a></li>
<li><a href="#peekfront---dynamic"><code>peekFront()</code></a></li>
<li><a href="#getint-index---dynamic"><code>get(int index)</code></a></li>
<li><a href="#isempty---boolean"><code>isEmpty()</code></a></li>
<li><a href="#clear---void"><code>clear()</code></a></li>
</ul>
<p><a class="anchor" id="autotoc_md960"></a></p><h5><code>new Deque()</code> -&gt; <code>Deque</code></h5>
<p>Creates an empty double-ended queue with initial capacity of 16. If you know the optimal size before-hand, use <a href="#new-dequeint-capacity---deque"><code>new Deque(int capacity)</code></a>.</p>
<div class="fragment"><div class="line">var deque = new Deque();</div>
<div class="line">deque.push(1, 2, 3);</div>
<div class="line">deque.shift(); //1</div>
<div class="line">deque.pop(); //3</div>
</div><!-- fragment --><hr  />
<p><a class="anchor" id="autotoc_md961"></a></p><h5><code>new Deque(Array items)</code> -&gt; <code>Deque</code></h5>
<p>Creates a double-ended queue from <code>items</code>.</p>
<div class="fragment"><div class="line">var deque = new Deque([1,2,3,4]);</div>
<div class="line">deque.shift(); //1</div>
<div class="line">deque.pop(); //4</div>
</div><!-- fragment --><hr  />
<p><a class="anchor" id="autotoc_md962"></a></p><h5><code>new Deque(int capacity)</code> -&gt; <code>Deque</code></h5>
<p>Creates an empty double-ended queue with the given <code>capacity</code>. <code>Capacity</code> should be the maximum amount of items the queue will hold at a given time.</p>
<p>The reason to give an initial capacity is to avoid potentially expensive resizing operations at runtime.</p>
<div class="fragment"><div class="line">var deque = new Deque(100);</div>
<div class="line">deque.push(1, 2, 3);</div>
<div class="line">deque.shift(); //1</div>
<div class="line">deque.pop(); //3</div>
</div><!-- fragment --><hr  />
<p><a class="anchor" id="autotoc_md963"></a></p><h5><code>push(dynamic items...)</code> -&gt; <code>int</code></h5>
<p>Push items to the back of this queue. Returns the amount of items currently in the queue after the operation.</p>
<div class="fragment"><div class="line">var deque = new Deque();</div>
<div class="line">deque.push(1);</div>
<div class="line">deque.pop(); //1</div>
<div class="line">deque.push(1, 2, 3);</div>
<div class="line">deque.shift(); //1</div>
<div class="line">deque.shift(); //2</div>
<div class="line">deque.shift(); //3</div>
</div><!-- fragment --><p><b>Aliases:</b> <code>enqueue</code>, <code>insertBack</code></p>
<hr  />
<p><a class="anchor" id="autotoc_md964"></a></p><h5><code>unshift(dynamic items...)</code> -&gt; <code>int</code></h5>
<p>Unshift items to the front of this queue. Returns the amount of items currently in the queue after the operation.</p>
<div class="fragment"><div class="line">var deque = new Deque([2,3]);</div>
<div class="line">deque.unshift(1);</div>
<div class="line">deque.toString(); //&quot;1,2,3&quot;</div>
<div class="line">deque.unshift(-2, -1, 0);</div>
<div class="line">deque.toString(); //&quot;-2,-1,0,1,2,3&quot;</div>
</div><!-- fragment --><p><b>Aliases:</b> <code>insertFront</code></p>
<hr  />
<p><a class="anchor" id="autotoc_md965"></a></p><h5><code>pop()</code> -&gt; <code>dynamic</code></h5>
<p>Pop off the item at the back of this queue.</p>
<p>Note: The item will be removed from the queue. If you simply want to see what's at the back of the queue use <a href="#peekback---dynamic"><code>peekBack()</code></a> or <a href="#getint-index---dynamic"><code>.get(-1)</code></a>.</p>
<p>If the queue is empty, <code>undefined</code> is returned. If you need to differentiate between <code>undefined</code> values in the queue and <code>pop()</code> return value - check the queue <code>.length</code> before popping.</p>
<div class="fragment"><div class="line">var deque = new Deque([1,2,3]);</div>
<div class="line">deque.pop(); //3</div>
<div class="line">deque.pop(); //2</div>
<div class="line">deque.pop(); //1</div>
<div class="line">deque.pop(); //undefined</div>
</div><!-- fragment --><p><b>Aliases:</b> <code>removeBack</code></p>
<hr  />
<p><a class="anchor" id="autotoc_md966"></a></p><h5><code>shift()</code> -&gt; <code>dynamic</code></h5>
<p>Shifts off the item at the front of this queue.</p>
<p>Note: The item will be removed from the queue. If you simply want to see what's at the front of the queue use <a href="#peekfront---dynamic"><code>peekFront()</code></a> or <a href="#getint-index---dynamic"><code>.get(0)</code></a>.</p>
<p>If the queue is empty, <code>undefined</code> is returned. If you need to differentiate between <code>undefined</code> values in the queue and <code>shift()</code> return value - check the queue <code>.length</code> before shifting.</p>
<div class="fragment"><div class="line">var deque = new Deque([1,2,3]);</div>
<div class="line">deque.shift(); //1</div>
<div class="line">deque.shift(); //2</div>
<div class="line">deque.shift(); //3</div>
<div class="line">deque.shift(); //undefined</div>
</div><!-- fragment --><p><b>Aliases:</b> <code>removeFront</code>, <code>dequeue</code></p>
<hr  />
<p><a class="anchor" id="autotoc_md967"></a></p><h5><code>toArray()</code> -&gt; <code>Array</code></h5>
<p>Returns the items in the queue as an array. Starting from the item in the front of the queue and ending to the item at the back of the queue.</p>
<div class="fragment"><div class="line">var deque = new Deque([1,2,3]);</div>
<div class="line">deque.push(4);</div>
<div class="line">deque.unshift(0);</div>
<div class="line">deque.toArray(); //[0,1,2,3,4]</div>
</div><!-- fragment --><p><b>Aliases:</b> <code>toJSON</code></p>
<hr  />
<p><a class="anchor" id="autotoc_md968"></a></p><h5><code>peekBack()</code> -&gt; <code>dynamic</code></h5>
<p>Returns the item that is at the back of this queue without removing it.</p>
<p>If the queue is empty, <code>undefined</code> is returned.</p>
<div class="fragment"><div class="line">var deque = new Deque([1,2,3]);</div>
<div class="line">deque.push(4);</div>
<div class="line">deque.peekBack(); //4</div>
</div><!-- fragment --><hr  />
<p><a class="anchor" id="autotoc_md969"></a></p><h5><code>peekFront()</code> -&gt; <code>dynamic</code></h5>
<p>Returns the item that is at the front of this queue without removing it.</p>
<p>If the queue is empty, <code>undefined</code> is returned.</p>
<div class="fragment"><div class="line">var deque = new Deque([1,2,3]);</div>
<div class="line">deque.push(4);</div>
<div class="line">deque.peekFront(); //1</div>
</div><!-- fragment --><hr  />
<p><a class="anchor" id="autotoc_md970"></a></p><h5><code>get(int index)</code> -&gt; <code>dynamic</code></h5>
<p>Returns the item that is at the given <code>index</code> of this queue without removing it.</p>
<p>The index is zero-based, so <code>.get(0)</code> will return the item that is at the front, <code>.get(1)</code> will return the item that comes after and so on.</p>
<p>The index can be negative to read items at the back of the queue. <code>.get(-1)</code> returns the item that is at the back of the queue, <code>.get(-2)</code> will return the item that comes before and so on.</p>
<p>Returns <code>undefined</code> if <code>index</code> is not a valid index into the queue.</p>
<div class="fragment"><div class="line">var deque = new Deque([1,2,3]);</div>
<div class="line">deque.get(0); //1</div>
<div class="line">deque.get(1); //2</div>
<div class="line">deque.get(2); //3</div>
<div class="line"> </div>
<div class="line">deque.get(-1); //3</div>
<div class="line">deque.get(-2); //2</div>
<div class="line">deque.get(-3); //1</div>
</div><!-- fragment --><p><b>Note</b>: Even though indexed accessor (e.g. <code>queue[0]</code>) could <em>appear</em> to return a correct value <em>sometimes</em>, this is completely unreliable. The numeric slots of the deque object are internally used as an optimization and have no meaningful order or meaning to outside. Always use <code>.get()</code>.</p>
<p><b>Note</b>: The implementation has O(1) random access using <code>.get()</code>.</p>
<hr  />
<p><a class="anchor" id="autotoc_md971"></a></p><h5><code>isEmpty()</code> -&gt; <code>boolean</code></h5>
<p>Return <code>true</code> if this queue is empty, <code>false</code> otherwise.</p>
<div class="fragment"><div class="line">var deque = new Deque();</div>
<div class="line">deque.isEmpty(); //true</div>
<div class="line">deque.push(1);</div>
<div class="line">deque.isEmpty(); //false</div>
</div><!-- fragment --><hr  />
<p><a class="anchor" id="autotoc_md972"></a></p><h5><code><a class="el" href="range__traits_8hpp.html#a29625773406e727f503a10af9fa8ea0c">clear()</a></code> -&gt; <code>void</code></h5>
<p>Remove all items from this queue. Does not change the queue's capacity.</p>
<div class="fragment"><div class="line">var deque = new Deque([1,2,3]);</div>
<div class="line">deque.toString(); //&quot;1,2,3&quot;</div>
<div class="line">deque.clear();</div>
<div class="line">deque.toString(); //&quot;&quot;</div>
</div><!-- fragment --><hr  />
<p>#Performance</p>
<p>Clone the repo and <code>npm install</code>. Then run the <code>bench</code> script.</p>
<h2><a class="anchor" id="autotoc_md973"></a>
1000 items in the queue</h2>
<pre class="fragment">double-ended-queue x 15,532,714 ops/sec ±0.19% (96 runs sampled)
built-in array x 6,501,398 ops/sec ±0.87% (95 runs sampled)
node-deque x 2,938,068 ops/sec ±3.50% (68 runs sampled)
</pre><h2><a class="anchor" id="autotoc_md974"></a>
2 million items in the queue</h2>
<pre class="fragment">double-ended-queue x 14,425,547 ops/sec ±0.17% (94 runs sampled)
node-deque x 2,815,628 ops/sec ±10.56% (76 runs sampled)
built-in array x 19.23 ops/sec ±0.35% (51 runs sampled)
</pre><p>Noteworthy is just how bad the degradation can be for built-in array when V8 cannot use the trick. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
