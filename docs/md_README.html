<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fuzzuf: fuzzuf</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fuzzuf
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">fuzzuf </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://jenkins.atla.ricsec.co.jp/view/fuzzuf/job/fuzzuf-branch_build/"><img src="https://jenkins.atla.ricsec.co.jp/buildStatus/icon?job=fuzzuf-branch_build" alt="Build Status" class="inline"/></a></p>
<p><b>fuzzuf</b> (**fuzz**ing **u**nification **f**ramework) is a fuzzing framework with its own DSL to describe a fuzzing loop by constructing building blocks of fuzzing primitives.</p>
<p>For build instructions and a tutorial, please follow building.md and tutorial.md.</p>
<h1><a class="anchor" id="autotoc_md238"></a>
Why use fuzzuf?</h1>
<p>fuzzuf enables a flexible definition of a fuzzing loop defined in each fuzzer by describing it as combinations of building blocks with DSL notations while keeping extensibility for its original fuzzer. It already has various fuzzer implementations including AFL, VUzzer, and libFuzzer that can be further extended by users.</p>
<h1><a class="anchor" id="autotoc_md239"></a>
HierarFlow</h1>
<p>fuzzuf utilizes its own DSL called <b>HierarFlow</b> for fuzzing loop statements. It is implemented on top of a C++ language with the grammar made to look like a tree structure to describe a fuzzing loop as a combination of building blocks.</p>
<p>With HierarFlow, we can write both existing and new fuzzers in a neat and tidy way, as the structure of a fuzzing loop can clearly be shown. For instance, we can divide an AFL fuzzer (which has already been implemented on fuzzuf as a template!) into multiple fuzzing primitives that include <em>PUT executor</em>, <em>mutators</em> (both deterministic and random), <em>dictionary updater</em>, and so on. Users can implement each primitive in C++ code and connect them together with HierarFlow's operator to eventually construct a fuzzing loop of a fuzzer they want to achieve.</p>
<h2><a class="anchor" id="autotoc_md240"></a>
Example: AFL in HierarFlow</h2>
<p><a href="/include/fuzzuf/algorithms/afl/templates/afl_fuzzer.hpp">The following short snippet</a> represents AFL in HierarFlow:</p>
<div class="fragment"><div class="line">fuzz_loop &lt;&lt; (</div>
<div class="line">     cull_queue</div>
<div class="line">  || select_seed</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">select_seed &lt;&lt; (</div>
<div class="line">     consider_skip_mut</div>
<div class="line">  || retry_calibrate</div>
<div class="line">  || trim_case</div>
<div class="line">  || calc_score</div>
<div class="line">  || apply_det_muts &lt;&lt; (</div>
<div class="line">         bit_flip1 &lt;&lt; execute &lt;&lt; (normal_update || construct_auto_dict)</div>
<div class="line">      || bit_flip_other &lt;&lt; execute.HardLink() &lt;&lt; normal_update.HardLink()</div>
<div class="line">      || byte_flip1 &lt;&lt; execute.HardLink() &lt;&lt; (normal_update.HardLink()</div>
<div class="line">                                           || construct_eff_map)</div>
<div class="line">      || byte_flip_other &lt;&lt; execute.HardLink() &lt;&lt; normal_update.HardLink()</div>
<div class="line">      || arith &lt;&lt; execute.HardLink() &lt;&lt; normal_update.HardLink()</div>
<div class="line">      || interest &lt;&lt; execute.HardLink() &lt;&lt; normal_update.HardLink()</div>
<div class="line">      || user_dict_overwrite &lt;&lt; execute.HardLink() &lt;&lt; normal_update.HardLink()</div>
<div class="line">      || auto_dict_overwrite &lt;&lt; execute.HardLink() &lt;&lt; normal_update.HardLink()</div>
<div class="line">     )</div>
<div class="line">   || apply_rand_muts &lt;&lt; (</div>
<div class="line">           havoc &lt;&lt; execute.HardLink() &lt;&lt; normal_update.HardLink()</div>
<div class="line">        || splicing &lt;&lt; execute.HardLink() &lt;&lt; normal_update.HardLink()</div>
<div class="line">      )</div>
<div class="line">   || abandon_node</div>
<div class="line">);</div>
</div><!-- fragment --><p>This simply shows how flexible and powerful HierarFlow is. Please refer to the document for more details.</p>
<h1><a class="anchor" id="autotoc_md241"></a>
Benefits of using fuzzuf</h1>
<p>There are mainly four advantages of writing fuzzers on fuzzuf framework: <br  />
</p>
<ul>
<li>Can describe a fuzzing loop with combinations of each fuzzing primitive <br  />
 fuzzuf constructs a fuzzing loop with a combination of fuzzing primitives (an individual step in a fuzzing loop) like building blocks. Since each block can be appended, removed, replaced, and resuable, fuzzuf can keep the high modularity of every fuzzing loop defined.</li>
<li>A flexible, user-definable fuzzing loops <br  />
 Since existing fuzzing frameworks tend to have fixed, or hard-coded fuzzing loops inside the frameworks themselves, their users could not manipulate their behaviors. fuzzuf can assign and implement a routine for each fuzzing primitive divided, and describe and modify the structure of a fuzzing loop as a user wants.</li>
<li>Easy to compare a derived fuzzer to its original <br  />
 It is not rare that fuzzing researchers and enthusiasts fork an existing fuzzer to implement their own idea on top of it. As a matter of fact, a lot of academic works have showcased numerous AFL-based fuzzers reflecting their idea. By leveraging fuzzuf DSL's building block-like characteristics and reusing existing fuzzing primitives, users can highly accelerate their new fuzzer's development process. Moreover, by comparing diffs of DSLs between the original fuzzer and its derivatives, the enhancements can smoothly be spotted at a glance (not only for users themselves, but also for reviewers and other researchers).</li>
<li>AFL fuzzer as a template <br  />
 On fuzzuf, AFL is available as a fuzzer (C++) template as well. This means that the cost to implement and review a new or existing AFL-based fuzzer has been lowered a lot by utilizing it. For example, fuzzuf's AFLFast is built upon this template. Only a few modifications in routines and a struct which records a fuzzer state are required to change, and it keeps its original's flow unchanged.</li>
</ul>
<h1><a class="anchor" id="autotoc_md242"></a>
List of Currently Available Fuzzers</h1>
<p>fuzzuf comes with the following fuzzers implemented by default. To see the overview and how to them from CLI, please follow the links provided below. <br  />
 Note, when using fuzzuf from CLI, you have to separate global options (options available for all fuzzers) and local options (fuzzer specific options) with <code>--</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><a class="el" href="classFuzzer.html">Fuzzer</a> </th><th class="markdownTableHeadNone">Type </th><th class="markdownTableHeadNone">Description </th><th class="markdownTableHeadNone">CLI Usage </th><th class="markdownTableHeadNone">Algorithm Overview </th><th class="markdownTableHeadNone">Frida mode  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">AFL </td><td class="markdownTableBodyNone">Greybox </td><td class="markdownTableBodyNone">A re-implementation of general purpose fuzzer, representing a CGF. Also available as a template for its derivatives. </td><td class="markdownTableBodyNone"><a href="/docs/algorithms/afl/algorithm_en.md#how-to-use-fuzzufs-afl-cli">How to use fuzzuf's AFL CLI</a> </td><td class="markdownTableBodyNone"><a href="/docs/algorithms/afl/algorithm_en.md#algorithm-overview">Algorithm Overview</a> </td><td class="markdownTableBodyNone">:white_check_mark:  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">AFLFast </td><td class="markdownTableBodyNone">Greybox </td><td class="markdownTableBodyNone">An implementation of AFLFast, utilizing an AFL template.<br  />
The algorithm tries to increase its performance by manipulating the power schedule. </td><td class="markdownTableBodyNone"><a href="/docs/algorithms/aflfast/algorithm_en.md#cli-usage">CLI Usage</a> </td><td class="markdownTableBodyNone"><a href="/docs/algorithms/aflfast/algorithm_en.md#algorithm-overview">Algorithm Overview</a> </td><td class="markdownTableBodyNone">:white_check_mark:  </td></tr>
</table>
<p>|IJON|Greybox|A fuzzer that can fuzz PUTs in an <em>internal-state-aware</em> manner with manual annotations to PUTs.|<a href="/docs/algorithms/ijon/algorithm_en.md#how-to-use-fuzzufs-ijon-cli">CLI Usage</a>|<a href="/docs/algorithms/ijon/algorithm_en.md#algorithm-overview">Algorithm Overview</a> |VUzzer|Greybox|A mutation-based fuzzer guess data structures by analyzing the PUT control flow and the data flow.|Read <a href="/docs/algorithms/vuzzer/algorithm_en.md#prerequisite">Prerequisite</a> first, then <a href="docs/algorithms/vuzzer/algorithm_en.md#usage-on-cli">Usage on CLI</a>|<a href="/docs/algorithms/vuzzer/algorithm_en.md#algorithm-overview">Algorithm Overview</a> |libFuzzer|Greybox|CGF included in the LLVM project's compiler-rt libraries.|<a href="/docs/algorithms/libfuzzer/manual.md#how-to-use-libfuzzer-on-fuzzuf">How to use libFuzzer on fuzzuf</a>|<a href="/docs/algorithms/libfuzzer/algorithm_en.md#what-is-libfuzzer">What is libFuzzer?</a> |Nezha|Greybox|A fuzzer originates from libFuzzer that tries to find defects in the program by executing programs having different implementations with the same input and compares its execution results (differential fuzzing).|<a href="/docs/algorithms/nezha/manual.md#how-to-use-nezha-on-fuzzuf">How to use Nezha on fuzzuf</a>|TBD |DIE|Greybox|A fuzzer for JavaScript engines preserving the aspect of the test cases through the mutation process|<a href="/docs/algorithms/die/algorithm_en.md#usage-on-cli">Usage on CLI</a>|<a href="/docs/algorithms/die/algorithm_en.md#overview-of-algorithm">Overview of Algorithm</a> |Nautilus|Greybox|A coverage-guided grammar-based fuzzer that generates test cases according to the user-defined grammar|<a href="/docs/algorithms/nautilus/algorithm_en.md#2-usage-on-cli">Usage on CLI</a>|<a href="/docs/algorithms/nautilus/algorithm_en.md#3-algorithm">Overview of Algorithm</a></p>
<h1><a class="anchor" id="autotoc_md243"></a>
Why not Rust?</h1>
<p>We have considered migrating the framework from C++ to Rust because it is safer and has a neat ecosystem during development. However, despite the attempts and the discussions, we concluded that we would not switch the language. The reason why is explained in detail here.</p>
<h1><a class="anchor" id="autotoc_md244"></a>
API Reference</h1>
<p>API reference generated by doxygen is available <a href="https://fuzzuf.github.io/fuzzuf-doxygen-docs/">here</a>.</p>
<h1><a class="anchor" id="autotoc_md245"></a>
License</h1>
<p>fuzzuf is licensed under the GNU Affero General Public License v3.0. Some codes originate from external projects are licensed under their own licenses. Please refer to <a href="/LICENSE">LICENSE</a> for details.</p>
<h1><a class="anchor" id="autotoc_md246"></a>
Acknowledgements</h1>
<p>This project has received funding from the Acquisition, Technology &amp; Logistics Agency (ATLA) under the Innovative Science and Technology Initiative for Security 2020 (JPJ004596). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
