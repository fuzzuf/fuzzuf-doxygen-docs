<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fuzzuf: libFuzzer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fuzzuf
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">libFuzzer </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md243"></a>
libFuzzerとは</h1>
<p><a href="https://llvm.org/docs/LibFuzzer.html">https://llvm.org/docs/LibFuzzer.html</a></p>
<p>libFuzzerはLLVMプロジェクトのcompiler-rtのライブラリの1つとして提供されているgreybox fuzzingの実装である。</p>
<p>libFuzzerはcorpusに記録されている入力値をもとにmutationで新しい入力値を作り、その入力値でfuzzingの対象を実行し、カバレッジ等を調べて珍しいパスを通っていたり、珍しい振る舞いをしていれば新しい入力値をcorpusに追加するという操作を繰り返す。ここからわかるようにlibFuzzerは大雑把にはAFLとよく似た手順で動くfuzzerである。ただしAFLと比較して以下の点が大きく異なっている</p>
<ul>
<li>入力値のランダムな範囲を整数値がテキストで書かれた物と見做してパースし、演算を行ってからテキストに戻して元の位置に書き直すmutatorを持つ(ChangeASCIIInt)</li>
<li>2つの入力値を引数にとって両者をランダムに混ぜ合わせるmutatorを持つ(Crossover)</li>
<li>LLVMの-fsanitize-coverage=trace-cmpを使って比較演算のログを取り、比較の両辺の値を辞書として用いるmutatorを持つ(CMP)</li>
<li>辞書の単語を使って作った入力値がcorpusに追加された場合にその単語が自動で登録されていくPersistent Auto Dictionaryを持つ</li>
<li>mutationを所定の回数(デフォルト 100回)実行して作った新しい入力値を実行してもcorpusに追加すべき実行結果が得られなかった場合、決められた回数(デフォルト 5回)まで同じ入力値に対してmutationをやり直す</li>
<li>入力値の特定の範囲だけをmutationするように指示することができる(Mask)</li>
<li>LLVM 10以降では実行結果にどの程度の価値があるかを表すenergyを、その実行結果がどの程度珍しいパスを通っているか等(feature)から求める。corpusから入力値を選ぶ際にある入力値が選ばれる確率はenergyによって変化する(entropic scheduling)。LLVM 9以前では1つ以上のfeatureを新たに見つけている実行結果に対して、後から見つかった物程高い確率で選ばれるような重み付け(vanilla scheduling)がなされる。</li>
<li>featureの種類には最大値が設けられていて、新しいfeatureを発見した際に既知のfeatureが最大数に達していた場合、featureのうち最も多くの実行結果に共通して現れている物(abbundant feature)は以後無視されるようになる。無視されたfeatureはenergyの計算にも影響しなくなる。これによって一度珍しいと判断された実行結果も後から同じような実行結果が頻繁に見つかると価値が低下し、価値が無くなると(energy == 0)corpusから削除される。</li>
<li>過去の実行結果と同じfeatureを得られるより短い入力値を発見した場合、corpusの要素をより短い方で置き換える(reduce)</li>
</ul>
<p>libFuzzerはmutationで作った新しい入力値を引数としてハーネスと呼ばれる関数を呼び出す。ユーザーはlibFuzzerが生成した入力値を使ってfuzzingの対象となる関数を呼び出すハーネスを実装し、対象の関数を含むライブラリとlibFuzzerをリンクする。このようなfuzzingの方法は子プロセスを生成する古典的なfuzzerの実装と比較して性能面で有利である(子プロセスの生成は一般に時間がかかる)。</p>
<p>fuzzingの対象とfuzzerの実装自体が同じプロセス内に存在するため</p>
<ul>
<li>fuzzer自体のカバレッジがカウントされないようにする必要がある</li>
<li>サニタイザが異常を報告した時、それがfuzzing対象から報告された物かfuzzer自体から報告されたものか区別できる必要がある</li>
</ul>
<p>といった問題が生じる。</p>
<p>libFuzzerは前者を達成するために-fsanitize-coverage=edgeを付けてビルドされたfuzzingの対象と-fsanitize-coverage=edgeを付けずにビルドされたlibFuzzerのライブラリをリンクする。このとき、libFuzzer側のインライン関数がfuzzingの対象のビルド時にコンパイルされる事が無いように注意深く実装されている。ハーネスのカバレッジが記録される点は気にしない。</p>
<p>後者を達成する為にlibFuzzerはハーネスの実行前と実行後にサニタイザが抱えている情報を漁り、必要に応じて書き換えている。LLVMのサニタイザの実装は将来に渡って互換性が保たれるAPIではない(し、実際時々変わっている)が、libFuzzer自体がLLVMの一部でLLVMと一緒にバージョンアップしている為、対応するバージョンのLLVMのサニタイザと組み合わせられれば良い、というスタンスでお構いなしに中身を漁っている。</p>
<p>乱数生成器はLLVM 8まではmt19937が使われていて、LLVM 9以降はminstd_randが使われている</p>
<p>このほかlibFuzzerには将来的に-fsanitize=dataflowを使って入力値のどの部分が分岐に寄与したかを調べる為の物と思われるコードが転がっているが、現状ここから得た情報は有効に活用されていない。</p>
<p>libFuzzerはLLVM 4でllvm本体のlib以下に実装され、LLVM 5でcompiler-rtに移動された。</p>
<h1><a class="anchor" id="autotoc_md244"></a>
fuzzufにおける実装</h1>
<p>移植の状況</p>
<h1><a class="anchor" id="autotoc_md245"></a>
libFuzzerの仕組み</h1>
<p>libFuzzerは以下の疑似コードのような手順で動く。</p>
<p>ここでinitial_inputは初期シード、targetはfuzzingを行う対象、total_countはターゲットを実行する回数、mutation_depthは同じ入力値に対してmutationを行う回数を表す。</p>
<div class="fragment"><div class="line">count = 0;</div>
<div class="line">unique_feature_set = {}</div>
<div class="line">global_feature_freqs = {}</div>
<div class="line">corpus = {}</div>
<div class="line">// 全ての初期シードについて</div>
<div class="line">for( input in initial_inputs ) {</div>
<div class="line">  // ターゲットを一度実行し</div>
<div class="line">  exec_result = execute( target, input );</div>
<div class="line">  // 実行結果をcorpusに追加</div>
<div class="line">  add_to_corpus( corpus, exec_result, input );</div>
<div class="line">}</div>
<div class="line">// 入力値が選ばれる確率を更新</div>
<div class="line">dist = update_distribution( corpus );</div>
<div class="line">// 試行回数がtotal_countに達するまで</div>
<div class="line">while( count &lt; total_count ) {</div>
<div class="line">  // mutation_depth(libFuzzerではデフォルト5回)に達するまで </div>
<div class="line">  for( i = 0; i &lt; mutation_depth; ++i ) {</div>
<div class="line">    // corpusから入力値を1つ選び</div>
<div class="line">    [old_exec_result,input] = corpus.select_seed();</div>
<div class="line">    // 入力値のmutationを行い</div>
<div class="line">    mut_input = mutate( dist, input );</div>
<div class="line">    // ターゲットを実行</div>
<div class="line">    exec_result = execute( target, mut_input );</div>
<div class="line">    // 実行結果からfeatureを求め</div>
<div class="line">    features = collect_features( old_exec_result, exec_result, unique_feature_set, global_feature_freqs );</div>
<div class="line">    // 新しいfeatureを発見していたら</div>
<div class="line">    if( is_interesting( features ) ) {</div>
<div class="line">      // 実行結果と入力値をcorpusに追加</div>
<div class="line">      corpus.add( exec_result, mut_input );</div>
<div class="line">      // 入力値が選ばれる確率を更新</div>
<div class="line">      dist = update_distribution( corpus );</div>
<div class="line">      // 試行回数をインクリメント</div>
<div class="line">      ++count;</div>
<div class="line">      // corpusに実行結果を追加した場合mutation_depthに達していなくてもループを抜ける</div>
<div class="line">      break;</div>
<div class="line">    }</div>
<div class="line">    else {</div>
<div class="line">      // 試行回数をインクリメント</div>
<div class="line">      ++count;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>libFuzzerはターゲットの実行結果のうち注目すべき特徴にIDを与えたfeatureを用いる</p>
<p>featureは基本的にedge coverageのedgeのインデックスとそのedgeを通過した回数から計算される</p>
<p>global_feature_freqsは過去に現れたfeatureの出現回数をfeature毎にカウントしている</p>
<p>unique_feature_setは1回以上現れているが出現回数が少ないfeatureのidを持っている</p>
<p>unique_feature_setには最大長があり、長さが最大に達している状態で新しいfeatureが見つかった場合、unique_feature_setの中で最も頻繁に見つかっているfeatureがunique_feature_setから外れる</p>
<p>is_interestingはターゲットの実行結果から見つかったfeatureの中に、unique_feature_setに並んでいる珍しいfeatureが1つ以上含まれていた場合にtrueになる</p>
<p>crashedはターゲットの実行結果が正常終了以外の場合にtrueになる</p>
<p>実行結果は</p>
<ul>
<li>見つかった珍しいfetureの数</li>
<li>初期シードからこの入力値に至るまでにmutationを行った回数</li>
<li>実行時間がどの程度平均から外れているか</li>
</ul>
<p>に基づいてenergyが計算される</p>
<p>update_distributionはenergyが高い実行結果程次のselect_seedで選ばれやすくなるように乱数の分布を更新する この結果libFuzzerのselect_seedは</p>
<ul>
<li>珍しいfeatureを出した入力が集中的に選択される</li>
<li>mutationの度に新しいfeatureの発見を繰り返している入力が集中的に選択される</li>
<li>同じだけのfeatureが見つかるならより短時間で処理できる入力が優遇される</li>
</ul>
<p>ような動きをする</p>
<h1><a class="anchor" id="autotoc_md246"></a>
Mutatorノード</h1>
<p>libFuzzerには13種類のmutatorが実装されており、新しい入力値を作る際にはそれらの中から1つを均等な確率で選んで実行する操作を100回繰り返す</p>
<p>実装されているmutatorは以下の通り</p>
<h2><a class="anchor" id="autotoc_md247"></a>
EraseBytes</h2>
<p>与えられたバイト列のランダムな位置からランダムな長さ(最大でバイト列の長さの半分)を削除する</p>
<p>既にバイト列が1バイト「以下」だったら何もしない</p>
<p>fuzzufではfuzzuf::algorithm::libfuzzer::erase_byteノードが担当し、fuzzuf::algorithm::libfuzzer::mutator::erase_byteで処理される</p>
<h2><a class="anchor" id="autotoc_md248"></a>
InsertByte</h2>
<p>与えられたバイト列のランダムな位置に128バイト以下かつ最大長を超えないランダムな長さの値を挿入する</p>
<p>挿入される値は0x00か0xFFがランダムに選ばれる</p>
<p>既にバイト列が最大長だったら何もしない</p>
<p>fuzzufではfuzzuf::algorithm::libfuzzer::insert_byteノードが担当し、fuzzuf::algorithm::libfuzzer::mutator::insert_byteで処理される</p>
<h2><a class="anchor" id="autotoc_md249"></a>
InsertRepeatedBytes</h2>
<p>与えられたバイト列のランダムな位置に128バイト以下かつ最大長を超えないランダムな長さの値を挿入する</p>
<p>挿入される値は0x00か0xFFがランダムに選ばれる</p>
<p>既にバイト列が最大長だったら何もしない</p>
<p>fuzzufではfuzzuf::algorithm::libfuzzer::insert_repeated_bytesノードが担当し、fuzzuf::algorithm::libfuzzer::mutator::insert_repeated_bytesで処理される</p>
<h2><a class="anchor" id="autotoc_md250"></a>
ChangeByte</h2>
<p>与えられたバイト列のランダムな位置の1バイトをランダムな値に書き換える</p>
<p>バイト列が何故か最大長より長い場合は何もしない</p>
<p>fuzzufではfuzzuf::algorithm::libfuzzer::change_byteノードが担当し、fuzzuf::algorithm::libfuzzer::mutator::change_byteで処理される</p>
<h2><a class="anchor" id="autotoc_md251"></a>
ChangeBit</h2>
<p>与えられたバイト列のランダムな位置のランダムな1bitを反転させる</p>
<p>バイト列が何故か最大長より長い場合は何もしない</p>
<p>fuzzufではfuzzuf::algorithm::libfuzzer::change_bitノードが担当し、fuzzuf::algorithm::libfuzzer::mutator::change_bitで処理される</p>
<h2><a class="anchor" id="autotoc_md252"></a>
ShuffleBytes</h2>
<p>与えられたバイト列のランダムな位置から残りのバイト数以下かつ8バイト以下のランダムなバイト数の範囲をstd::shuffleする</p>
<p>バイト列が何故か最大長より長い場合およびバイト列が空の場合は何もしない</p>
<p>fuzzufではfuzzuf::algorithm::libfuzzer::shuffle_bytesノードが担当し、fuzzuf::algorithm::libfuzzer::mutator::shuffle_bytesで処理される</p>
<h2><a class="anchor" id="autotoc_md253"></a>
ChangeASCIIInt</h2>
<p>バイト列が何故か最大長より長い場合およびバイト列が空の場合は何もしない</p>
<p><a href="https://github.com/llvm/llvm-project/blob/main/compiler-rt/lib/fuzzer/FuzzerMutate.cpp#L109">https://github.com/llvm/llvm-project/blob/main/compiler-rt/lib/fuzzer/FuzzerMutate.cpp#L109</a></p>
<p>ChangeASCIIInt 与えられたバイト列のランダムな位置から線形探索して最初に’0’以上’9’以下の値が見つかった位置をbegin、beginから線形探索して最初に’0’以上’9’以下でない値が見つかった位置をendとし、beginからendの範囲を先頭を最上位の位とする10進数と見做して64bit符号無し整数型の値を得る</p>
<p>この値に</p>
<ul>
<li>インクリメント</li>
<li>デクリメント</li>
<li>倍にする</li>
<li>半分にする</li>
<li>ランダムな値に置き換える</li>
</ul>
<p>のいずれかの操作をランダムに選択肢して行い、beginからendの間に先頭を最上位の位として書き直す</p>
<p>操作によって桁が増えてbeginからendの間に収まらない場合は上の桁を捨てる</p>
<p>バイト列が何故か最大長より長い場合は何もしない</p>
<p>fuzzufではfuzzuf::algorithm::libfuzzer::change_ascii_integerノードが担当し、fuzzuf::algorithm::libfuzzer::mutator::change_ascii_integerで処理される</p>
<h2><a class="anchor" id="autotoc_md254"></a>
ChangeBinInt</h2>
<p>uint8_t、uint16_t、uint32_t、uint64_tの4種類の型から1つTが均等な確率で選ばれる</p>
<p>与えられたバイト列の先頭から終端-sizeof(T)の範囲のランダムな位置からsizeof(T)バイトをT型の整数と見做す</p>
<p>位置が先頭から64バイト以内の場合1/4の確率でその位置にバイト列の全長を書き込む</p>
<p>それ以外の場合はその位置の値に-10以上10以下の値を足す</p>
<p>書き込み時には1/2の確率でエンディアンの変換が行われる</p>
<p>fuzzufではfuzzuf::algorithm::libfuzzer::change_binary_integerノードが担当し、fuzzuf::algorithm::libfuzzer::mutator::change_binary_integerで処理される</p>
<h2><a class="anchor" id="autotoc_md255"></a>
CopyPart</h2>
<p>1/2の確率でCopyPartOfまたはInsertPartOfを行う</p>
<h3><a class="anchor" id="autotoc_md256"></a>
CopyPartOf</h3>
<p>与えられたバイト列のランダムな位置から残りの長さ以下のサイズの領域をランダムな位置にコピーする</p>
<p>コピーはmemmoveで行われ、コピー元とコピー先は重複する可能性がある</p>
<h3><a class="anchor" id="autotoc_md257"></a>
InsertPartOf</h3>
<p>与えられたバイト列のランダムな位置から残りの長さ以下かつ最大サイズまでの残りサイズ以下のサイズの領域をランダムな位置に挿入する</p>
<p>fuzzufではfuzzuf::algorithm::libfuzzer::copy_partノードが担当し、fuzzuf::algorithm::libfuzzer::mutator::copy_partで処理される</p>
<h2><a class="anchor" id="autotoc_md258"></a>
CrossOver</h2>
<p>1/3の確率でCrossOverWithの値と与えられたバイト列でCrossOver、CopyPartOf、InsertPartOfのいずれかを行う</p>
<h3><a class="anchor" id="autotoc_md259"></a>
CrossOver</h3>
<p>バイト列Aとバイト列Bから交互に1バイトづつデータを取り出して並べた新しいバイト列を作る</p>
<h2><a class="anchor" id="autotoc_md260"></a>
CopyPartOf</h2>
<p>バイト列Aのランダムな位置から残りの長さ以下かつ最大サイズまでの残りサイズ以下のサイズの領域をバイト列Bのランダムな位置からサイズ分の領域に書き込む</p>
<h3><a class="anchor" id="autotoc_md261"></a>
InsertPartOf</h3>
<p>バイト列Aのランダムな位置から残りの長さ以下かつ最大サイズまでの残りサイズ以下のサイズの領域をバイト列Bのランダムな位置に挿入する</p>
<p>fuzzufではfuzzuf::algorithm::libfuzzer::crossoverノードが担当し、fuzzuf::algorithm::libfuzzer::mutator::crossoverで処理される</p>
<h2><a class="anchor" id="autotoc_md262"></a>
ManualDict</h2>
<p>あらかじめ用意した辞書にあるバイト列のうち1つをランダムに選び、与えられたバイト列のランダムな位置に挿入する</p>
<p>fuzzufではfuzzuf::algorithm::libfuzzer::static_dictionaryノードが担当し、fuzzuf::algorithm::libfuzzer::mutator::dictionaryで処理される</p>
<h2><a class="anchor" id="autotoc_md263"></a>
PersAutoDict</h2>
<p>新しいfeatureの発見に繋がった辞書の要素が自動的に追加されていく辞書にあるバイト列のうち1つをランダムに選び、与えられたバイト列のランダムな位置に挿入する</p>
<p>fuzzufではfuzzuf::algorithm::libfuzzer::dynamic_dictionaryノードが担当し、fuzzuf::algorithm::libfuzzer::mutator::dictionaryで処理される static_dictionaryおよびdynamic_dictionaryがdict_entryに記録した辞書の利用記録をfuzzufではfuzzuf::algorithm::libfuzzer::update_dictionaryノードに渡すと、fuzzuf::algorithm::libfuzzer::mutator::update_dictionaryで辞書の要素の追加が行われる</p>
<h2><a class="anchor" id="autotoc_md264"></a>
CMP</h2>
<p>オプションCMPが有効な場合に追加される</p>
<p>この機能を使うにはまず-fsanitize-coverage=trace-cmpを使って比較演算で分岐した際に何と何を何の演算子で比較したかを記録する</p>
<p>CMPは比較に使われた値と同じ値を入力から探し、それを条件分岐が異なる側に入るように書き換える</p>
<p>入力に比較したのと同じ値が入っていたからと言って、それが必ずしも比較された値そのものとは限らないが、ある程度の確率で分岐方向を変えられる事を期待する</p>
<p>fuzzufではこのmutatorは使えない</p>
<h2><a class="anchor" id="autotoc_md265"></a>
カスタムmutator</h2>
<p>libFuzzerには独自のmutatorを追加する為にCustomMutatorとCustomCrossOverが用意されている。fuzzufでは特別なノードを用意するよりノードを自作して追加する方が簡単な為、これらのmutatorに対応するノードは用意していない</p>
<h1><a class="anchor" id="autotoc_md266"></a>
制御ノード</h1>
<p>HierarFlow上でlibFuzzerを実現する為に必要な制御構文を実現する為に以下のノードを実装している</p>
<h2><a class="anchor" id="autotoc_md267"></a>
ForEach</h2>
<p>rangeの要素を1つづつ指定された引数にセットして、後続のノードを実行する。後続のノードはrangeの要素数と同じ回数実行される。</p>
<p>fuzzuf::algorithm::libfuzzer::static_for_eachはノードにrangeを持ち、fuzzuf::algorithm::libfuzzer::dynamic_for_eachは指定された引数からrangeを得る。</p>
<h2><a class="anchor" id="autotoc_md268"></a>
IfNewCoverage</h2>
<p>指定された引数に含まれている実行結果がadd_to_corpusで1回以上corpusに追加されている物だった場合後続のノードの要素を全て実行する。そうでなかった場合後続のノードの最後の要素だけを実行する。</p>
<p>fuzzuf::algorithm::libfuzzer::if_new_coverageノードが担当する。</p>
<h2><a class="anchor" id="autotoc_md269"></a>
RandomCall</h2>
<p>後続のノードの要素のうち最後の要素を除く1つをランダムに選んで実行し、その後最後の要素を実行する。</p>
<p>fuzzuf::algorithm::libfuzzer::random_callノードが担当する</p>
<h2><a class="anchor" id="autotoc_md270"></a>
Repeat</h2>
<p>後続のノードのうち最後の要素を除く要素を指定された回数繰り返し実行し、その後最後の要素を実行する。</p>
<p>fuzzuf::algorithm::libfuzzer::static_repeatはノードがカウンタと繰り返し回数を持ち、後続のノードを実行する度にこのノードがカウンタをインクリメントさせる。</p>
<p>fuzzuf::algorithm::libfuzzer::partially_dynmic_repeatはノードが繰り返し回数だけを持ち、引数で指定されたカウンタの値が繰り返し回数に達しない限り後続のノードを実行する。カウンタは別途Appendノードなどを使ってインクリメントしなければならない。</p>
<p>fuzzuf::algorithm::libfuzzer::dynmic_repeatはノードが一切の情報を持たず、引数で指定されたカウンタの値が引数で指定された繰り返し回数に達しない限り後続のノードを実行する。カウンタは別途Appendノードなどを使ってインクリメントしなければならない 。</p>
<h2><a class="anchor" id="autotoc_md271"></a>
RepeatUntilNewCoverage</h2>
<p>指定された引数に含まれている実行結果がadd_to_corpusで1回以上corpusに追加されている物だった場合後続のノードの最後の要素を実行して処理を完了させる。それ以外の場合corpusに追加されるまで後続のノードの最後の要素以外を実行する。</p>
<p>fuzzuf::algorithm::libfuzzer::repeat_until_new_coverageノードが担当する</p>
<h2><a class="anchor" id="autotoc_md272"></a>
Nop</h2>
<p>これ自体は何もしないで後続のノードを実行する。</p>
<p>主にnop &gt;&gt;より前の||で結合されたノードとnop &gt;&gt;より後の||で結合されたノードを明示的に異なるグループにする為に用いる。</p>
<p>fuzzuf::algorithm::libfuzzer::nopノードが担当する</p>
<h2><a class="anchor" id="autotoc_md273"></a>
Assign</h2>
<p>指定された引数に指定された値を代入する。</p>
<p>fuzzuf::algorithm::libfuzzer::static_assignは指定された引数にノードが持っている値を代入する。</p>
<p>fuzzuf::algorithm::libfuzzer::dynamic_assignは指定された引数に、指定された引数の値を代入する。</p>
<h2><a class="anchor" id="autotoc_md274"></a>
Append</h2>
<p>指定された引数に指定された値を追加する。</p>
<p>fuzzuf::algorithm::libfuzzer::static_assignは指定された引数にノードが持っている値を追加する。</p>
<p>fuzzuf::algorithm::libfuzzer::dynamic_assignは指定された引数に、指定された引数の値を追加する。</p>
<h1><a class="anchor" id="autotoc_md275"></a>
Executeノード</h1>
<h2><a class="anchor" id="autotoc_md276"></a>
Execute</h2>
<p>fuzzufのExecutorを持ち、引数で受け取った入力値を使ってfuzzingの対象を実行し、カバレッジと標準出力と実行結果を引数で指定された場所に出力する</p>
<p>fuzzuf::algorithm::libfuzzer::executeノードが担当し、fuzzuf::algorithm::libfuzzer::executor::executeが実際にexecutorをRunする。</p>
<h1><a class="anchor" id="autotoc_md277"></a>
Feedbackノード</h1>
<p>これらのノードは実行結果をcorpusに追加するかどうかの判断と実際に追加する処理を含む</p>
<h2><a class="anchor" id="autotoc_md278"></a>
CollectFeatures</h2>
<p>引数で受け取ったカバレッジと実行結果からfeatureを求めて引数で指定された場所に出力する。</p>
<p>fuzzuf::algorithm::libfuzzer::collect_featuresノードが担当し、fuzzuf::algorithm::libfuzzer::executor::collect_featuresが実際の計算を行う。</p>
<h2><a class="anchor" id="autotoc_md279"></a>
AddToCorpus</h2>
<p>引数で受け取ったfeatureに未発見のものが含まれていた場合、またはforce_add_to_corpusがtrueの場合引数で指定されたcorpusに引数で指定された実行結果と入力値を追加する。</p>
<p>corpusに追加された実行結果はadded_to_corpusがtrueになる。これはIfNewCoverageノード、RepeatUntilNewCoverageノード、AddToSolutionsノードの振る舞いに影響する。</p>
<p>fuzzuf::algorithm::libfuzzer::add_to_corpusノードが担当し、fuzzuf::algorithm::libfuzzer::executor::add_to_corpusが実際の追加を行う。</p>
<h2><a class="anchor" id="autotoc_md280"></a>
AddToSolutions</h2>
<p>引数で受け取った実行結果のadd_to_corpusがtrueの場合引数で指定されたcorpusに実行結果と入力値を追加する。</p>
<p>crashed_onlyがtrueの場合実行結果が正常終了以外の場合のみcorpusに実行結果と入力値を追加する。</p>
<p>AddToCorpusと異なり出力先のディレクトリを指定する事ができ、入力値を永続化する事ができる。</p>
<p>fuzzuf::algorithm::libfuzzer::add_to_solutionsノードが担当し、fuzzuf::algorithm::libfuzzer::executor::add_to_solutionsが実際の追加を行う。</p>
<h2><a class="anchor" id="autotoc_md281"></a>
UpdateDistribution</h2>
<p>引数で受け取ったcorpusの状態に基づいてcorpusの各要素がRandomChoiceノードで選ばれる確率を計算し直す。</p>
<p>fuzzuf::algorithm::libfuzzer::update_distributionノードが担当し、fuzzuf::algorithm::libfuzzer::select_seed::update_distributionが実際の計算を行う。</p>
<h2><a class="anchor" id="autotoc_md282"></a>
RandomChoice</h2>
<p>引数で受け取ったcorpusのなかからランダムな1つを指定された引数にコピーする。</p>
<p>個々の実行結果が選ばれる確率はUpdateDistributionノードで決定される(このノードが先に実行されていなければならない)。</p>
<p>fuzzuf::algorithm::libfuzzer::random_choiceノードが担当し、fuzzuf::algorithm::libfuzzer::select_seed::select_seedが実際の選択を行う。</p>
<h1><a class="anchor" id="autotoc_md283"></a>
デバッグノード</h1>
<p>主にデバッグの為にfuzzingの途中で引数の値をダンプしたりするノード</p>
<h2><a class="anchor" id="autotoc_md284"></a>
Dump</h2>
<p>指定された引数の内容をto_stringを使ってシリアライズし、ノードが持つコールバックを使って出力する。</p>
<p>fuzzuf::algorithm::libfuzzer::static_dumpが担当する。</p>
<h2><a class="anchor" id="autotoc_md285"></a>
PrintSttusForNewUnit</h2>
<p>引数で受け取った実行結果の内容をlibFuzzerのFuzzer::PrintStatusForNewUnitと同じ形式でノードが持つコールバックを使って出力する。</p>
<p>fuzzuf::algorithm::libfuzzer::print_status_for_new_unitが担当する。</p>
<h1><a class="anchor" id="autotoc_md286"></a>
標準的なlibFuzzerの組み方</h1>
<p>test/algorithms/libfuzzer/execute.cpp の中で組み立てているものがオリジナルのlibFuzzerのFuzzer::Loop()に近い処理になっている </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
