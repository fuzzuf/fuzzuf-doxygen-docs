<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fuzzuf: fuzzuf::algorithm::libfuzzer Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fuzzuf
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>fuzzuf</b></li><li class="navelem"><b>algorithm</b></li><li class="navelem"><a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html">libfuzzer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">fuzzuf::algorithm::libfuzzer Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1AddToCorpus.html">AddToCorpus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert execution result to corpus if that has features Note that, <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1CollectFeatures.html" title="Calculate features of specified execution result. &quot;Feature&quot; is a outstanding feature of the execution...">CollectFeatures</a> must be applied to the execution result ahead, or the feature count is left to 0, and added result will never be selected by ChooseRandom Seed. The node takes 4 paths for state, corpus, input and exec_result.  <a href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1AddToCorpus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1AddToCorpus_3_01R_07Args_8_8_8_08_00_01Path_01_4.html">AddToCorpus&lt; R(Args...), Path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1AddToSolution.html">AddToSolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert execution result to solutions if the result is added to corpus and target returned error status on exit. The node takes 2 paths for input and exec_result.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1AddToSolution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1AddToSolution_3_01R_07Args_8_8_8_08_00_01Path_01_4.html">AddToSolution&lt; R(Args...), Path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1BasicExecInputSetIterator.html">BasicExecInputSetIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1BasicExecInputSetIterator_3_01false_00_01Reference_01_4.html">BasicExecInputSetIterator&lt; false, Reference &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1BasicExecInputSetIterator_3_01true_00_01Reference_01_4.html">BasicExecInputSetIterator&lt; true, Reference &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1ById.html">ById</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1ByName.html">ByName</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1ChooseRandomSeed.html">ChooseRandomSeed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select one input from corpus randomly and copy it to the specified value. This Node use the corpus specified by first element of Path and copy input to value specifed by second element of Path. The node takes 5 path for state, corpus, RNG, input and execution result.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1ChooseRandomSeed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1ChooseRandomSeed_3_01R_07Args_8_8_8_08_00_01Path_01_4.html">ChooseRandomSeed&lt; R(Args...), Path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Clamp.html">Clamp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Clamp.html" title="Clamp the value specified by the Path by min and max. The node takes 1 path for the value.">Clamp</a> the value specified by the Path by min and max. The node takes 1 path for the value.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Clamp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Clamp_3_01R_07Args_8_8_8_08_00_01Path_01_4.html">Clamp&lt; R(Args...), Path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1CollectFeatures.html">CollectFeatures</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate features of specified execution result. "Feature" is a outstanding feature of the execution which has unique ID. In most case, entering a new edge that is not covered by previous executions is a feature. "Features" is a vector of feature. libFuzzer calculate weight of the execution result that affects by features. If <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1ChooseRandomSeed.html" title="Select one input from corpus randomly and copy it to the specified value. This Node use the corpus sp...">ChooseRandomSeed</a> is using non-uniform distribution, input of higher weighted execution result is selected more frequentry. The node takes 5 paths for state, corpus, input, execution result and coverage.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1CollectFeatures.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1CollectFeatures_3_01R_07Args_8_8_8_08_00_01Path_01_4.html">CollectFeatures&lt; R(Args...), Path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Config.html">Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">libFuzzer parameters  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Divide.html">Divide</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke child nodes once for each n visits.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Divide.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1Divide_3_01R_07Args_8_8_8_08_00_01Path_01_4.html">Divide&lt; R(Args...), Path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1DynamicMask.html">DynamicMask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This node masks input using the mask specified by the Path Only masked elements of input are passed to child nodes. This node is intended to limit range to mutate. The node takes 2 paths for mask and input.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1DynamicMask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1DynamicMask_3_01R_07Args_8_8_8_08_00_01Path_01_4.html">DynamicMask&lt; R(Args...), Path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1DynamicRepeat.html">DynamicRepeat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke all child nodes until loop counter is equal or greater than total cycles. Total cycles is specified by the Path. The node takes 2 paths for loop counter and total cycles. Note that loop counter must be incremented maually, or this node will never complete.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1DynamicRepeat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1DynamicRepeat_3_01R_07Args_8_8_8_08_00_01Path_01_4.html">DynamicRepeat&lt; R(Args...), Path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1EntropicConfig.html">EntropicConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">libFuzzer parameters affecting on entropic mode  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1EntropicConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1ExecInputSetRange.html">ExecInputSetRange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Execute.html">Execute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run target with input specified by the Path, and acquire coverage, outputs, execution result to the values specified by the Path. The node takes 4 path for input, output, coverage and execution result.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Execute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Execute_3_01R_07Args_8_8_8_08_00_01Executor_00_01Path_01_4.html">Execute&lt; R(Args...), Executor, Path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1ForEachDynamicData.html">ForEachDynamicData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This node invokes all child nodes for each values in the container specified by the Path. On each loop head, a value from the container is assigned to to value specified by the Path. This node modifies flow. The node takes 2 paths. 1 for container and the other for writing a value from container.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1ForEachDynamicData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1ForEachDynamicData_3_01R_07Args_8_8_8_08_00_01Path_01_4.html">ForEachDynamicData&lt; R(Args...), Path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1ForEachStaticData.html">ForEachStaticData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This node invokes all child nodes for each values in the container defined at the node creation. On each loop head, a value from the container is assigned to to value specified by the Path. This node modifies flow. The node takes 1 path to write a value from container.  <a href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1ForEachStaticData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1ForEachStaticData_3_01R_07Args_8_8_8_08_00_01Data_00_01Path_01_4.html">ForEachStaticData&lt; R(Args...), Data, Path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1FullCorpus.html">FullCorpus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1FuzzerCreateInfo.html">FuzzerCreateInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1IfNewCoverage.html">IfNewCoverage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke all child nodes if the condition below are satisfied.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1IfNewCoverage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1IfNewCoverage_3_01R_07Args_8_8_8_08_00_01Path_01_4.html">IfNewCoverage&lt; R(Args...), Path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1InputInfo.html">InputInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">execution result This class contains values retrived from executor and scratch values to calculate weight All values in Input Info of original implementation has been ported, yet some of them are not used due to some functionalities are not ported.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1InputInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1is__full__corpus.html">is_full_corpus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function to check if the type satisfies <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1FullCorpus.html">FullCorpus</a> concept.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1is__full__corpus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1is__full__corpus_3_01T_00_01std_1_1enable__if__t_3_01iece45420b53942d8156809a990340065.html">is_full_corpus&lt; T, std::enable_if_t&lt; is_partial_corpus_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().corpus)&gt; &gt; &amp;&amp;std::is_same_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().inputs)&gt;, ExecInputSet &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1is__input__info.html">is_input_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function to check if the type satisfies <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1InputInfo.html" title="execution result This class contains values retrived from executor and scratch values to calculate we...">InputInfo</a> concept.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1is__input__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1is__input__info_3_01T_00_01std_1_1enable__if__t_3_01st0896142d691ddc0b79624caa86528d94.html">is_input_info&lt; T, std::enable_if_t&lt; std::is_same_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().id)&gt;, testcase_id_t &gt; &amp;&amp;std::is_same_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().enabled)&gt;, bool &gt; &amp;&amp;std::is_void_v&lt; utils::void_t&lt; decltype(std::chrono::duration_cast&lt; std::chrono::microseconds &gt;(std::declval&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().time_of_unit)&gt;&gt;()))&gt; &gt; &amp;&amp;std::is_integral_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().features_count)&gt; &gt; &amp;&amp;std::is_integral_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().executed_mutations_count)&gt; &gt; &amp;&amp;std::is_same_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().never_reduce)&gt;, bool &gt; &amp;&amp;std::is_same_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().may_delete_file)&gt;, bool &gt; &amp;&amp;std::is_same_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().has_focus_function)&gt;, bool &gt; &amp;&amp;std::is_same_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().reduced)&gt;, bool &gt; &amp;&amp;std::is_same_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().needs_energy_update)&gt;, bool &gt; &amp;&amp;std::is_floating_point_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().energy)&gt; &gt; &amp;&amp;std::is_floating_point_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().sum_incidence)&gt; &gt; &amp;&amp;std::is_integral_v&lt; utils::range::RangeValueT&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().unique_feature_set)&gt; &gt; &gt; &amp;&amp;std::is_same_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().status)&gt;, PUTExitReasonType &gt; &amp;&amp;std::is_integral_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().signal)&gt; &gt; &amp;&amp;std::is_floating_point_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().weight)&gt; &gt; &amp;&amp;std::is_integral_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().found_unique_features)&gt; &gt; &amp;&amp;std::is_same_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().added_to_corpus)&gt;, bool &gt; &amp;&amp;std::is_same_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().sha1)&gt;, std::string &gt; &amp;&amp;std::is_integral_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().input_size)&gt; &gt; &amp;&amp;std::is_void_v&lt; utils::void_t&lt; decltype(std::declval&lt; T &amp; &gt;().updateEnergy(std::declval&lt; std::size_t &gt;(), std::declval&lt; bool &gt;(), std::declval&lt; std::chrono::microseconds &gt;()))&gt; &gt; &amp;&amp;std::is_same_v&lt; decltype(std::declval&lt; T &amp; &gt;().delete_feature_freq(std::declval&lt; std::uint32_t &gt;())), bool &gt; &amp;&amp;std::is_void_v&lt; utils::void_t&lt; decltype(std::declval&lt; T &amp; &gt;().updateFeatureFrequency(std::declval&lt; std::uint32_t &gt;()))&gt; &gt; &amp;&amp;std::is_convertible_v&lt; T, bool &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1is__partial__corpus.html">is_partial_corpus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function to check if the type satisfies PartialCorpus concept.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1is__partial__corpus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1is__partial__corpus_3_01T_00_01std_1_1enable__if__t_3_23381f408e49cdd8cd5b2a8645ebf02b.html">is_partial_corpus&lt; T, std::enable_if_t&lt; is_input_info_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(*std::declval&lt; T &amp; &gt;().template get&lt; Sequential &gt;().begin())&gt; &gt; &amp;&amp;is_input_info_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(*std::declval&lt; T &amp; &gt;().template get&lt; ByName &gt;().begin())&gt; &gt; &amp;&amp;is_input_info_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(*std::declval&lt; T &amp; &gt;().template get&lt; ById &gt;().begin())&gt; &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1IsPiecewiseConstantDistribution_3_01std_1_1piecewise__7ad936411920d624cec6cbd264343429.html">IsPiecewiseConstantDistribution&lt; std::piecewise_constant_distribution&lt; T... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1IsState.html">IsState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function to check if the type satisfies <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1State.html" title="Struct to hold libFuzzer state.">State</a> concept.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1IsState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1IsState_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is_b885bc24361f3b70f3a10aa932e95479.html">IsState&lt; T, std::enable_if_t&lt; std::is_same_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().config)&gt;, Config &gt; &amp;&amp;is_std_distribution_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().corpus_distribution)&gt; &gt; &amp;&amp;std::is_convertible_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().distribution_needs_update)&gt;, bool &gt; &amp;&amp;std::is_integral_v&lt; utils::range::RangeValueT&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().rare_features)&gt; &gt; &gt; &amp;&amp;std::is_integral_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().freq_of_most_abundant_rare_feature)&gt; &gt; &amp;&amp;std::is_integral_v&lt; utils::range::RangeValueT&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().global_feature_freqs)&gt; &gt; &gt; &amp;&amp;std::is_integral_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().executed_mutations_count)&gt; &gt; &amp;&amp;std::is_integral_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().added_features_count)&gt; &gt; &amp;&amp;std::is_integral_v&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().updated_features_count)&gt; &gt; &amp;&amp;std::is_integral_v&lt; utils::range::RangeValueT&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().input_sizes_per_feature)&gt; &gt; &gt; &amp;&amp;std::is_integral_v&lt; utils::range::RangeValueT&lt; utils::type_traits::RemoveCvrT&lt; decltype(std::declval&lt; T &amp; &gt;().smallest_element_per_feature)&gt; &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1LibFuzzer.html">LibFuzzer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Marker.html">Marker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This node generates "mark" event with event detail defined at the node creation. The event is received by NodeTracer, if one or more NodeTracers are passed by arguments.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Marker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Marker_3_01R_07Args_8_8_8_08_00_01T_01_4.html">Marker&lt; R(Args...), T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1MutationHistoryEntry.html">MutationHistoryEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Options.html">Options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Order.html">Order</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1PartiallyDynamicRepeat.html">PartiallyDynamicRepeat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke all child nodes until loop counter is equal or greater than total cycles. Total cycles is defined at the node creation. The node takes 1 path for loop counter. Note that loop counter must be incremented maually, or this node will never complete.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1PartiallyDynamicRepeat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1PartiallyDynamicRepeat_3_01R_07Args_8_8_8_08_00_01Path_01_4.html">PartiallyDynamicRepeat&lt; R(Args...), Path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1PrintStatusForNewUnit.html">PrintStatusForNewUnit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print execution result and fuzzer state as in the format similar to original implementation. The node takes 7 paths for input, execution result, max length, mutation history, dictionary history, fuzzer loop count and date of started fuzzing.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1PrintStatusForNewUnit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1PrintStatusForNewUnit_3_01R_07Args_8_8_8_08_00_01Path_01_4.html">PrintStatusForNewUnit&lt; R(Args...), Path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1RandomCall.html">RandomCall</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke randomly selected one of the child nodes. If the node doesn't have any child nodes, nothing are invoked. This node modifies flow. The node takes 1 path for RNG.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1RandomCall.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1RandomCall_3_01R_07Args_8_8_8_08_00_01Path_01_4.html">RandomCall&lt; R(Args...), Path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1RepeatUntilMutated.html">RepeatUntilMutated</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke all child nodes until input is mutated n times or retry count exceeded m. n and m are defined at the node creation. Mutated count is retrived from mutation history. Since mutator fails to mutate in some cases(ex. the input length is max and trying to insert something) and mutation history is recorded only if mutation succeeded, total loop count can be larger than expected mutation count. This node modifies flow. The node takes 1 path for mutation history.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1RepeatUntilMutated.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1RepeatUntilMutated_3_01R_07Args_8_8_8_08_00_01Path_01_4.html">RepeatUntilMutated&lt; R(Args...), Path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1RepeatUntilNewCoverage.html">RepeatUntilNewCoverage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1RepeatUntilNewCoverage_3_01R_07Args_8_8_8_08_00_01Path_01_4.html">RepeatUntilNewCoverage&lt; R(Args...), Path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Sequential.html">Sequential</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1State.html">State</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold libFuzzer state.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1State.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1StaticAppend.html">StaticAppend</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append value defined at the node creation to the value specified by the Path. The node takes 1 path for output value.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1StaticAppend.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1StaticAppend_3_01R_07Args_8_8_8_08_00_01Path_01_4.html">StaticAppend&lt; R(Args...), Path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1StaticAssign.html">StaticAssign</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign value defined at the node creation to the value specified by the Path. The node takes 1 path for output value.  <a href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1StaticAssign.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1StaticAssign_3_01R_07Args_8_8_8_08_00_01Path_01_4.html">StaticAssign&lt; R(Args...), Path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1StaticDict.html">StaticDict</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert or Overwrite value selected from the dictionary defined at the node creation to the input specified by the Path. This node takes standard mutator parameters( rng, input, max length and mutation history ).  <a href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1StaticDict.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1StaticDict_3_01R_07Args_8_8_8_08_00_01Dict_00_01Path_01_4.html">StaticDict&lt; R(Args...), Dict, Path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1StaticDump.html">StaticDump</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a value specified by the Path and call sink to output it. This node is intended to make debugging easier. The node takes 1 path for the value.  <a href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1StaticDump.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1StaticDump_3_01R_07Args_8_8_8_08_00_01Path_01_4.html">StaticDump&lt; R(Args...), Path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1StaticMask.html">StaticMask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This node masks input using the mask defined at the node creation Only masked elements of input are passed to child nodes. This node is intended to limit range to mutate. The node takes one path for input.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1StaticMask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1StaticMask_3_01R_07Args_8_8_8_08_00_01Mask_00_01Path_01_4.html">StaticMask&lt; R(Args...), Mask, Path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1StaticRepeat.html">StaticRepeat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke all child nodes n times. n is defined at the node creation. This node modifies flow. The node takes no any Paths.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1StaticRepeat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1StaticRepeat_3_01R_07Args_8_8_8_08_4.html">StaticRepeat&lt; R(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1UpdateDistribution.html">UpdateDistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update probability of selecting each input in the corpus according to the state of corpus. The node takes 3 path for state( to retrive configs affecting to update ), corpus and RNG.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1UpdateDistribution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1UpdateDistribution_3_01R_07Args_8_8_8_08_00_01llvm__version_00_01Path_01_4.html">UpdateDistribution&lt; R(Args...), llvm_version, Path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1UpdateMaxLength.html">UpdateMaxLength</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">increase max length of input depending on fuzzing status.  <a href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1UpdateMaxLength.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1UpdateMaxLength_3_01R_07Args_8_8_8_08_00_01Path_01_4.html">UpdateMaxLength&lt; R(Args...), Path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Variables.html">Variables</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af69ee6f95e4d0a855d6e9798b28164d8"><td class="memTemplParams" colspan="2"><a id="af69ee6f95e4d0a855d6e9798b28164d8"></a>
template&lt;bool unwrap&gt; </td></tr>
<tr class="memitem:af69ee6f95e4d0a855d6e9798b28164d8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ExecInputSetIterator</b> = <a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1BasicExecInputSetIterator.html">BasicExecInputSetIterator</a>&lt; unwrap, <a class="el" href="classExecInput.html">ExecInput</a> &amp; &gt;</td></tr>
<tr class="separator:af69ee6f95e4d0a855d6e9798b28164d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab487eb829756483289ea3ff476ec4e10"><td class="memTemplParams" colspan="2"><a id="ab487eb829756483289ea3ff476ec4e10"></a>
template&lt;bool unwrap&gt; </td></tr>
<tr class="memitem:ab487eb829756483289ea3ff476ec4e10"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstExecInputSetIterator</b> = <a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1BasicExecInputSetIterator.html">BasicExecInputSetIterator</a>&lt; unwrap, const <a class="el" href="classExecInput.html">ExecInput</a> &amp; &gt;</td></tr>
<tr class="separator:ab487eb829756483289ea3ff476ec4e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cd9e0e2f5262c0a530ef59cb81c659"><td class="memTemplParams" colspan="2"><a id="ad4cd9e0e2f5262c0a530ef59cb81c659"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad4cd9e0e2f5262c0a530ef59cb81c659"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ChooseRandomSeedStdArgOrderT</b> = decltype(T::state &amp;&amp;T::corpus &amp;&amp;T::rng &amp;&amp;T::input &amp;&amp;T::exec_result)</td></tr>
<tr class="separator:ad4cd9e0e2f5262c0a530ef59cb81c659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bf28aded343faa6a7ddc2da4cc40eb"><td class="memItemLeft" align="right" valign="top"><a id="af1bf28aded343faa6a7ddc2da4cc40eb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MutationHistory</b> = std::vector&lt; <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1MutationHistoryEntry.html">MutationHistoryEntry</a> &gt;</td></tr>
<tr class="separator:af1bf28aded343faa6a7ddc2da4cc40eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec1e142725804d5df80cbf4165d1525"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#a3ec1e142725804d5df80cbf4165d1525">coverage_t</a> = std::vector&lt; std::uint8_t &gt;</td></tr>
<tr class="separator:a3ec1e142725804d5df80cbf4165d1525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7012dc2ff9f9d198a91a9d8ca9d634"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#ade7012dc2ff9f9d198a91a9d8ca9d634">output_t</a> = std::vector&lt; std::uint8_t &gt;</td></tr>
<tr class="separator:ade7012dc2ff9f9d198a91a9d8ca9d634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a40550db83af1fcbaf15d705b53624a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#a3a40550db83af1fcbaf15d705b53624a">PartialCorpus</a> = boost::multi_index::multi_index_container&lt; <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1InputInfo.html">InputInfo</a>, boost::multi_index::indexed_by&lt; boost::multi_index::sequenced&lt; boost::multi_index::tag&lt; <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Sequential.html">Sequential</a> &gt; &gt;, boost::multi_index::hashed_non_unique&lt; boost::multi_index::tag&lt; <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1ByName.html">ByName</a> &gt;, boost::multi_index::member&lt; <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1InputInfo.html">InputInfo</a>, std::string, &amp;<a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1InputInfo.html#a57d70de7d6b902de0e179349827b458a">InputInfo::name</a> &gt; &gt;, boost::multi_index::hashed_unique&lt; boost::multi_index::tag&lt; <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1ById.html">ById</a> &gt;, boost::multi_index::member&lt; <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1InputInfo.html">InputInfo</a>, <a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#ace18931d78fcca08efd871dbdb6d0629">testcase_id_t</a>, &amp;<a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1InputInfo.html#adde4ec71b3b21be500a27e1204d501a6">InputInfo::id</a> &gt; &gt;&gt; &gt;</td></tr>
<tr class="separator:a3a40550db83af1fcbaf15d705b53624a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace18931d78fcca08efd871dbdb6d0629"><td class="memItemLeft" align="right" valign="top"><a id="ace18931d78fcca08efd871dbdb6d0629"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#ace18931d78fcca08efd871dbdb6d0629">testcase_id_t</a> = std::uint64_t</td></tr>
<tr class="memdesc:ace18931d78fcca08efd871dbdb6d0629"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID to bind an input value and execution result. <br /></td></tr>
<tr class="separator:ace18931d78fcca08efd871dbdb6d0629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf61eaaf33e8c50a03809e10183a401e"><td class="memItemLeft" align="right" valign="top"><a id="aaf61eaaf33e8c50a03809e10183a401e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#aaf61eaaf33e8c50a03809e10183a401e">Version</a> = std::uint32_t</td></tr>
<tr class="memdesc:aaf61eaaf33e8c50a03809e10183a401e"><td class="mdescLeft">&#160;</td><td class="mdescRight">LLVM version that is encoded into 32bit integer. <br /></td></tr>
<tr class="separator:aaf61eaaf33e8c50a03809e10183a401e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:adc6122e14e4f6ca41ce0e1b92adb52f9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#adc6122e14e4f6ca41ce0e1b92adb52f9">ExecInputSetRangeInsertMode</a> { <b>NONE</b>, 
<b>IN_MEMORY</b>, 
<b>ON_DISK</b>
 }</td></tr>
<tr class="separator:adc6122e14e4f6ca41ce0e1b92adb52f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3c6c7d0aa8036975f71c562d084229ea"><td class="memItemLeft" align="right" valign="top"><a id="a3c6c7d0aa8036975f71c562d084229ea"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (std::string &amp;dest, const <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1EntropicConfig.html">EntropicConfig</a> &amp;value, std::size_t indent_count, const std::string &amp;indent) -&gt; bool</td></tr>
<tr class="separator:a3c6c7d0aa8036975f71c562d084229ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed9892e5ab26e075ade17d25bc72a0d"><td class="memItemLeft" align="right" valign="top"><a id="afed9892e5ab26e075ade17d25bc72a0d"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (std::string &amp;dest, const <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Config.html">Config</a> &amp;value, std::size_t indent_count, const std::string &amp;indent) -&gt; bool</td></tr>
<tr class="separator:afed9892e5ab26e075ade17d25bc72a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c701a0f7cd3c8917c611716b36b816"><td class="memItemLeft" align="right" valign="top"><a id="a90c701a0f7cd3c8917c611716b36b816"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (std::string &amp;dest, const <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1FuzzerCreateInfo.html">FuzzerCreateInfo</a> &amp;value, std::size_t indent_count, const std::string &amp;indent) -&gt; bool</td></tr>
<tr class="separator:a90c701a0f7cd3c8917c611716b36b816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2714a0725c078289ff5982683afbd76a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#a2714a0725c078289ff5982683afbd76a">toString</a> (std::string &amp;dest, const <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1InputInfo.html">InputInfo</a> &amp;value, std::size_t indent_count, const std::string &amp;indent) -&gt; bool</td></tr>
<tr class="separator:a2714a0725c078289ff5982683afbd76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b12a1157651367f7add83aa08b7104d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#a4b12a1157651367f7add83aa08b7104d">toString</a> (std::string &amp;dest, const <a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#a3a40550db83af1fcbaf15d705b53624a">PartialCorpus</a> &amp;value, std::size_t indent_count, const std::string &amp;indent) -&gt; bool</td></tr>
<tr class="separator:a4b12a1157651367f7add83aa08b7104d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0440b0b01d0e6dafa0027f412f931f7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#aa0440b0b01d0e6dafa0027f412f931f7">toString</a> (std::string &amp;dest, const <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1FullCorpus.html">FullCorpus</a> &amp;value, std::size_t indent_count, const std::string &amp;indent) -&gt; bool</td></tr>
<tr class="separator:aa0440b0b01d0e6dafa0027f412f931f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9171ea46e67bf208f467fb7b58f953e"><td class="memItemLeft" align="right" valign="top"><a id="ad9171ea46e67bf208f467fb7b58f953e"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>createOptions</b> (<a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Options.html">Options</a> &amp;dest) -&gt; std::tuple&lt; boost::program_options::options_description, boost::program_options::positional_options_description &gt;</td></tr>
<tr class="separator:ad9171ea46e67bf208f467fb7b58f953e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e3bc4600b8585a98bd270ddfd9e271"><td class="memItemLeft" align="right" valign="top"><a id="a77e3bc4600b8585a98bd270ddfd9e271"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>postProcess</b> (const boost::program_options::options_description &amp;desc, const boost::program_options::positional_options_description &amp;pd, int argc, const char *argv[], const <a class="el" href="structGlobalFuzzerOptions.html">GlobalFuzzerOptions</a> &amp;global, std::function&lt; void(std::string &amp;&amp;)&gt; &amp;&amp;sink, <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Options.html">Options</a> &amp;dest) -&gt; bool</td></tr>
<tr class="separator:a77e3bc4600b8585a98bd270ddfd9e271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fe2b9443667182f33da86fe756f53f"><td class="memItemLeft" align="right" valign="top"><a id="a02fe2b9443667182f33da86fe756f53f"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>loadInitialInputs</b> (<a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Options.html">Options</a> &amp;dest, std::minstd_rand &amp;rng) -&gt; <a class="el" href="classExecInputSet.html">ExecInputSet</a></td></tr>
<tr class="separator:a02fe2b9443667182f33da86fe756f53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa632fde8709e03e888f4cf0340ec5d8"><td class="memItemLeft" align="right" valign="top"><a id="aaa632fde8709e03e888f4cf0340ec5d8"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (std::string &amp;dest, const <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1State.html">State</a> &amp;value, std::size_t indent_count, const std::string &amp;indent) -&gt; bool</td></tr>
<tr class="separator:aaa632fde8709e03e888f4cf0340ec5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f83e85f0b133cfa923d59c89850b52d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#a6f83e85f0b133cfa923d59c89850b52d">lflog</a> (std::size_t x) -&gt; std::size_t</td></tr>
<tr class="separator:a6f83e85f0b133cfa923d59c89850b52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01bc8d619870f59d0b458ff94ec0dd9d"><td class="memTemplParams" colspan="2"><a id="a01bc8d619870f59d0b458ff94ec0dd9d"></a>
template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a01bc8d619870f59d0b458ff94ec0dd9d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CalcMaxLength</b> (const Range &amp;inputs) -&gt; std::enable_if_t&lt; utils::range::is_range_v&lt; utils::range::RangeValueT&lt; Range &gt;&gt;, std::size_t &gt;</td></tr>
<tr class="separator:a01bc8d619870f59d0b458ff94ec0dd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a975012c8f7a64f01103be5d00239de"><td class="memTemplParams" colspan="2">template&lt;typename F , typename Ord &gt; </td></tr>
<tr class="memitem:a2a975012c8f7a64f01103be5d00239de"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#a2a975012c8f7a64f01103be5d00239de">createMutator</a> (const <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1FuzzerCreateInfo.html">FuzzerCreateInfo</a> &amp;create_info)</td></tr>
<tr class="separator:a2a975012c8f7a64f01103be5d00239de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ef996649b4680eb7941066c14baaf1"><td class="memTemplParams" colspan="2">template&lt;typename F , typename Ord , typename Sink &gt; </td></tr>
<tr class="memitem:af5ef996649b4680eb7941066c14baaf1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#af5ef996649b4680eb7941066c14baaf1">createExecuteAndFeedback</a> (const fs::path &amp;target_path, const <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1FuzzerCreateInfo.html">FuzzerCreateInfo</a> &amp;create_info, bool force_add_to_corpus, bool may_delete_file, bool persistent, bool strict_match, const Sink &amp;sink)</td></tr>
<tr class="separator:af5ef996649b4680eb7941066c14baaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42392d472fd2c2643f27907e8dc262c"><td class="memTemplParams" colspan="2">template&lt;typename F , typename Ord , typename Sink &gt; </td></tr>
<tr class="memitem:af42392d472fd2c2643f27907e8dc262c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#af42392d472fd2c2643f27907e8dc262c">createInitialize</a> (const fs::path &amp;target_path, const <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1FuzzerCreateInfo.html">FuzzerCreateInfo</a> &amp;create_info, <a class="el" href="classExecInputSet.html">ExecInputSet</a> &amp;initial_inputs, bool strict_match, const Sink &amp;sink)</td></tr>
<tr class="separator:af42392d472fd2c2643f27907e8dc262c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fd8119ac5d70a0ea83b57effd67a1e"><td class="memTemplParams" colspan="2">template&lt;typename F , typename Ord , typename Sink &gt; </td></tr>
<tr class="memitem:a82fd8119ac5d70a0ea83b57effd67a1e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#a82fd8119ac5d70a0ea83b57effd67a1e">createRunone</a> (const fs::path &amp;target_path, const <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1FuzzerCreateInfo.html">FuzzerCreateInfo</a> &amp;create_info, <a class="el" href="classExecInputSet.html">ExecInputSet</a> &amp;, const Sink &amp;sink)</td></tr>
<tr class="separator:a82fd8119ac5d70a0ea83b57effd67a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8fe2715446bae7724b9b639f7e74fd"><td class="memTemplParams" colspan="2">template&lt;typename F , typename Ord , typename Sink &gt; </td></tr>
<tr class="memitem:abb8fe2715446bae7724b9b639f7e74fd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#abb8fe2715446bae7724b9b639f7e74fd">create</a> (const fs::path &amp;target_path, const <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1FuzzerCreateInfo.html">FuzzerCreateInfo</a> &amp;create_info, <a class="el" href="classExecInputSet.html">ExecInputSet</a> &amp;initial_inputs, const Sink &amp;sink)</td></tr>
<tr class="separator:abb8fe2715446bae7724b9b639f7e74fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf76296037a5043d0a3b97111e63941"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a6bf76296037a5043d0a3b97111e63941"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#a6bf76296037a5043d0a3b97111e63941">DoNothing</a> (Args &amp;&amp;...)</td></tr>
<tr class="separator:a6bf76296037a5043d0a3b97111e63941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074b59fb04a9dd706efe112545dfa6db"><td class="memItemLeft" align="right" valign="top"><a id="a074b59fb04a9dd706efe112545dfa6db"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FUZZUF_ALGORITHM_LIBFUZZER_HIERARFLOW_SIMPLE_FUNCTION</b> (<a class="el" href="classDynamicDict.html">DynamicDict</a>, mutator::Dictionary) namespace standard_order</td></tr>
<tr class="separator:a074b59fb04a9dd706efe112545dfa6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852c617a705900fa0aec4733dc74a981"><td class="memItemLeft" align="right" valign="top"><a id="a852c617a705900fa0aec4733dc74a981"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FUZZUF_ALGORITHM_LIBFUZZER_HIERARFLOW_SIMPLE_FUNCTION</b> (<a class="el" href="classUpdateDictionary.html">UpdateDictionary</a>, mutator::UpdateDictionary) namespace standard_order</td></tr>
<tr class="separator:a852c617a705900fa0aec4733dc74a981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39353d6c58848b9e468e290a1071f5c2"><td class="memItemLeft" align="right" valign="top"><a id="a39353d6c58848b9e468e290a1071f5c2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FUZZUF_ALGORITHM_LIBFUZZER_HIERARFLOW_SIMPLE_FUNCTION</b> (EraseBytes, mutator::EraseBytes) FUZZUF_ALGORITHM_LIBFUZZER_HIERARFLOW_SIMPLE_FUNCTION(InsertByte</td></tr>
<tr class="separator:a39353d6c58848b9e468e290a1071f5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed25ff82ac28b1a6faba4b2143d96ef"><td class="memItemLeft" align="right" valign="top"><a id="abed25ff82ac28b1a6faba4b2143d96ef"></a>
mutator::InsertByte&#160;</td><td class="memItemRight" valign="bottom"><b>FUZZUF_ALGORITHM_LIBFUZZER_HIERARFLOW_SIMPLE_FUNCTION</b> (InsertRepeatedBytes, mutator::InsertRepeatedBytes) FUZZUF_ALGORITHM_LIBFUZZER_HIERARFLOW_SIMPLE_FUNCTION(ChangeByte</td></tr>
<tr class="separator:abed25ff82ac28b1a6faba4b2143d96ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71bc3f5df9d641d007ac3e7d7b9f6b5a"><td class="memItemLeft" align="right" valign="top"><a id="a71bc3f5df9d641d007ac3e7d7b9f6b5a"></a>
mutator::InsertByte mutator::ChangeByte&#160;</td><td class="memItemRight" valign="bottom"><b>FUZZUF_ALGORITHM_LIBFUZZER_HIERARFLOW_SIMPLE_FUNCTION</b> (ChangeBit, mutator::ChangeBit) FUZZUF_ALGORITHM_LIBFUZZER_HIERARFLOW_SIMPLE_FUNCTION(ShuffleBytes</td></tr>
<tr class="separator:a71bc3f5df9d641d007ac3e7d7b9f6b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a07b8b01871e120256fc979e4f0704"><td class="memItemLeft" align="right" valign="top"><a id="ad7a07b8b01871e120256fc979e4f0704"></a>
mutator::InsertByte mutator::ChangeByte mutator::ShuffleBytes&#160;</td><td class="memItemRight" valign="bottom"><b>FUZZUF_ALGORITHM_LIBFUZZER_HIERARFLOW_SIMPLE_FUNCTION</b> (ChangeASCIIInteger, mutator::ChangeASCIIInteger) FUZZUF_ALGORITHM_LIBFUZZER_HIERARFLOW_SIMPLE_FUNCTION(ChangeBinaryInteger</td></tr>
<tr class="separator:ad7a07b8b01871e120256fc979e4f0704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98cfc928a249180c98027b18cef2ced8"><td class="memItemLeft" align="right" valign="top"><a id="a98cfc928a249180c98027b18cef2ced8"></a>
mutator::InsertByte mutator::ChangeByte mutator::ShuffleBytes mutator::ChangeBinaryInteger&#160;</td><td class="memItemRight" valign="bottom"><b>FUZZUF_ALGORITHM_LIBFUZZER_HIERARFLOW_SIMPLE_FUNCTION</b> (CopyPart, mutator::CopyPart) FUZZUF_ALGORITHM_LIBFUZZER_HIERARFLOW_SIMPLE_FUNCTION(Crossover</td></tr>
<tr class="separator:a98cfc928a249180c98027b18cef2ced8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301160f3e120b812b430beb5243de574"><td class="memItemLeft" align="right" valign="top"><a id="a301160f3e120b812b430beb5243de574"></a>
mutator::InsertByte mutator::ChangeByte mutator::ShuffleBytes mutator::ChangeBinaryInteger mutator::Crossover&#160;</td><td class="memItemRight" valign="bottom"><b>FUZZUF_ALGORITHM_LIBFUZZER_HIERARFLOW_SIMPLE_FUNCTION</b> (IncrementMutationsCount, mutator::IncrementMutationsCount) namespace standard_order</td></tr>
<tr class="separator:a301160f3e120b812b430beb5243de574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ceab672705d6acca0a5d40b643390f"><td class="memTemplParams" colspan="2">template&lt;typename V , typename RNG &gt; </td></tr>
<tr class="memitem:ac2ceab672705d6acca0a5d40b643390f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#ac2ceab672705d6acca0a5d40b643390f">random_value</a> (RNG &amp;rng, V max) -&gt; std::enable_if_t&lt; std::is_integral_v&lt; V &gt;, V &gt;</td></tr>
<tr class="separator:ac2ceab672705d6acca0a5d40b643390f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10903973045cb9c57d70dc40c71c2210"><td class="memTemplParams" colspan="2">template&lt;typename V , typename RNG &gt; </td></tr>
<tr class="memitem:a10903973045cb9c57d70dc40c71c2210"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#a10903973045cb9c57d70dc40c71c2210">random_value</a> (RNG &amp;rng) -&gt; std::enable_if_t&lt; std::is_integral_v&lt; V &gt; &amp;&amp;std::is_same_v&lt; bool, V &gt;, V &gt;</td></tr>
<tr class="separator:a10903973045cb9c57d70dc40c71c2210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3839395a03c170e4b9a8e3d14a1509c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#ab3839395a03c170e4b9a8e3d14a1509c">FUZZUF_CHECK_CAPABILITY</a> (HasIncrementUseCount1, has_IncrementUseCount1, std::declval&lt; T &amp; &gt;().increment_use_count()) FUZZUF_CHECK_CAPABILITY(HasIncrementUseCount2</td></tr>
<tr class="separator:ab3839395a03c170e4b9a8e3d14a1509c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe37ac6fb8da00a4de6e5fce94078a6f"><td class="memTemplParams" colspan="2"><a id="afe37ac6fb8da00a4de6e5fce94078a6f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afe37ac6fb8da00a4de6e5fce94078a6f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#afe37ac6fb8da00a4de6e5fce94078a6f">MakeVersion</a> (T major, T minor, T patch) -&gt; std::enable_if_t&lt; std::is_convertible_v&lt; T, std::uint32_t &gt;, <a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#aaf61eaaf33e8c50a03809e10183a401e">Version</a> &gt;</td></tr>
<tr class="memdesc:afe37ac6fb8da00a4de6e5fce94078a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert LLVM version triple to 32bit integer value. <br /></td></tr>
<tr class="separator:afe37ac6fb8da00a4de6e5fce94078a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a17815af26db6929b1087b1d54586c327"><td class="memTemplParams" colspan="2"><a id="a17815af26db6929b1087b1d54586c327"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a17815af26db6929b1087b1d54586c327"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_partial_corpus_v</b> = <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1is__partial__corpus.html">is_partial_corpus</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a17815af26db6929b1087b1d54586c327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6973dba0570c0f3a13a2d59f7e7d2a7"><td class="memTemplParams" colspan="2"><a id="ac6973dba0570c0f3a13a2d59f7e7d2a7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac6973dba0570c0f3a13a2d59f7e7d2a7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_full_corpus_v</b> = <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1is__full__corpus.html">is_full_corpus</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ac6973dba0570c0f3a13a2d59f7e7d2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd255c7974a3ac136e01f23ef80f3d7"><td class="memTemplParams" colspan="2"><a id="abfd255c7974a3ac136e01f23ef80f3d7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abfd255c7974a3ac136e01f23ef80f3d7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_input_info_v</b> = <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1is__input__info.html">is_input_info</a>&lt;T&gt;::value</td></tr>
<tr class="separator:abfd255c7974a3ac136e01f23ef80f3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec23950546b6934f1f876b9810d1f8ea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec23950546b6934f1f876b9810d1f8ea"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_piecewise_constant_distribution_v</b></td></tr>
<tr class="separator:aec23950546b6934f1f876b9810d1f8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf7428028b7e4f31bb677ac611f636c"><td class="memTemplParams" colspan="2"><a id="aeaf7428028b7e4f31bb677ac611f636c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeaf7428028b7e4f31bb677ac611f636c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_state_v</b> = <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1IsState.html">IsState</a>&lt;T&gt;::value</td></tr>
<tr class="separator:aeaf7428028b7e4f31bb677ac611f636c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927c0acd054f579f56051e15ff0b2195"><td class="memItemLeft" align="right" valign="top"><a id="a927c0acd054f579f56051e15ff0b2195"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>has_IncrementUseCount2</b></td></tr>
<tr class="separator:a927c0acd054f579f56051e15ff0b2195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1ec17437ac9095eade99363fdf646f"><td class="memItemLeft" align="right" valign="top"><a id="aae1ec17437ac9095eade99363fdf646f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>has_get_word1</b></td></tr>
<tr class="separator:aae1ec17437ac9095eade99363fdf646f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5fc42e3dd8db81417ea8ad7eee3e31"><td class="memItemLeft" align="right" valign="top"><a id="adb5fc42e3dd8db81417ea8ad7eee3e31"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>has_get_word2</b></td></tr>
<tr class="separator:adb5fc42e3dd8db81417ea8ad7eee3e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771a6a04d4baaa83f3a1154e96ef827b"><td class="memItemLeft" align="right" valign="top"><a id="a771a6a04d4baaa83f3a1154e96ef827b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>has_has_position_hint1</b></td></tr>
<tr class="separator:a771a6a04d4baaa83f3a1154e96ef827b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48705e66ba5fd6eabcfec51b182533a4"><td class="memItemLeft" align="right" valign="top"><a id="a48705e66ba5fd6eabcfec51b182533a4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>has_has_position_hint2</b></td></tr>
<tr class="separator:a48705e66ba5fd6eabcfec51b182533a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323d3b54b57a3a22665a03f791ffc25a"><td class="memItemLeft" align="right" valign="top"><a id="a323d3b54b57a3a22665a03f791ffc25a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>has_GetPositionHint1</b></td></tr>
<tr class="separator:a323d3b54b57a3a22665a03f791ffc25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61322531275b28ecae67e8100ee0a626"><td class="memItemLeft" align="right" valign="top"><a id="a61322531275b28ecae67e8100ee0a626"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>has_GetPositionHint2</b></td></tr>
<tr class="separator:a61322531275b28ecae67e8100ee0a626"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Decide max input value length using initial input values. If the longest initial input value is longer than ( 1 &lt;&lt; 20 ) bytes, the max input value length is ( 1 &lt;&lt; 20 ) If the longest initial input value is between 4096 bytes and ( 1 &lt;&lt; 20 ) bytes, the max input value length is the length of longest initial input value. If the longest initial input value is shorter or equal to 4096 bytes, the max input value length is 4096 This value is used as the default value of max input value length</p>
<p>Corresponding code of original libFuzzer implementation <a href="https://github.com/llvm/llvm-project/blob/llvmorg-12.0.1/compiler-rt/lib/fuzzer/FuzzerLoop.cpp#L373">https://github.com/llvm/llvm-project/blob/llvmorg-12.0.1/compiler-rt/lib/fuzzer/FuzzerLoop.cpp#L373</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Range</td><td>Range of range that contains initial inputs as element </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputs</td><td>Initial input values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max input value length </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a3ec1e142725804d5df80cbf4165d1525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec1e142725804d5df80cbf4165d1525">&#9670;&nbsp;</a></span>coverage_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#a3ec1e142725804d5df80cbf4165d1525">fuzzuf::algorithm::libfuzzer::coverage_t</a> = typedef std::vector&lt;std::uint8_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A container type that is available to store coverage </p>

<p class="definition">Definition at line <a class="el" href="common__types_8hpp_source.html#l00032">32</a> of file <a class="el" href="common__types_8hpp_source.html">common_types.hpp</a>.</p>

</div>
</div>
<a id="ade7012dc2ff9f9d198a91a9d8ca9d634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7012dc2ff9f9d198a91a9d8ca9d634">&#9670;&nbsp;</a></span>output_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#ade7012dc2ff9f9d198a91a9d8ca9d634">fuzzuf::algorithm::libfuzzer::output_t</a> = typedef std::vector&lt;std::uint8_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A container type that is available to store standard output </p>

<p class="definition">Definition at line <a class="el" href="common__types_8hpp_source.html#l00036">36</a> of file <a class="el" href="common__types_8hpp_source.html">common_types.hpp</a>.</p>

</div>
</div>
<a id="a3a40550db83af1fcbaf15d705b53624a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a40550db83af1fcbaf15d705b53624a">&#9670;&nbsp;</a></span>PartialCorpus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#a3a40550db83af1fcbaf15d705b53624a">fuzzuf::algorithm::libfuzzer::PartialCorpus</a> = typedef boost::multi_index::multi_index_container&lt; <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1InputInfo.html">InputInfo</a>, boost::multi_index::indexed_by&lt; boost::multi_index::sequenced&lt;boost::multi_index::tag&lt;<a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Sequential.html">Sequential</a>&gt; &gt;, boost::multi_index::hashed_non_unique&lt; boost::multi_index::tag&lt;<a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1ByName.html">ByName</a>&gt;, boost::multi_index::member&lt;<a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1InputInfo.html">InputInfo</a>, std::string, &amp;<a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1InputInfo.html#a57d70de7d6b902de0e179349827b458a">InputInfo::name</a>&gt; &gt;, boost::multi_index::hashed_unique&lt; boost::multi_index::tag&lt;<a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1ById.html">ById</a>&gt;, boost::multi_index::member&lt;<a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1InputInfo.html">InputInfo</a>, <a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#ace18931d78fcca08efd871dbdb6d0629">testcase_id_t</a>, &amp;<a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1InputInfo.html#adde4ec71b3b21be500a27e1204d501a6">InputInfo::id</a>&gt; &gt;&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Since libFuzzer uses insertion order, corpus must provide both sequential index and hashed index. </p>

<p class="definition">Definition at line <a class="el" href="corpus_8hpp_source.html#l00054">54</a> of file <a class="el" href="corpus_8hpp_source.html">corpus.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="adc6122e14e4f6ca41ce0e1b92adb52f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6122e14e4f6ca41ce0e1b92adb52f9">&#9670;&nbsp;</a></span>ExecInputSetRangeInsertMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#adc6122e14e4f6ca41ce0e1b92adb52f9">fuzzuf::algorithm::libfuzzer::ExecInputSetRangeInsertMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enums to indicate behaviour of insertion to <a class="el" href="classfuzzuf_1_1algorithm_1_1libfuzzer_1_1ExecInputSetRange.html">ExecInputSetRange</a> </p>

<p class="definition">Definition at line <a class="el" href="exec__input__set__range_8hpp_source.html#l00158">158</a> of file <a class="el" href="exec__input__set__range_8hpp_source.html">exec_input_set_range.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="abb8fe2715446bae7724b9b639f7e74fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8fe2715446bae7724b9b639f7e74fd">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename Ord , typename Sink &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto fuzzuf::algorithm::libfuzzer::create </td>
          <td>(</td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>target_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1FuzzerCreateInfo.html">FuzzerCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>create_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classExecInputSet.html">ExecInputSet</a> &amp;&#160;</td>
          <td class="paramname"><em>initial_inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Sink &amp;&#160;</td>
          <td class="paramname"><em>sink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build all process of libFuzzer using HierarFlow </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Input function type of HierarFlow node </td></tr>
    <tr><td class="paramname">Ord</td><td>Type to specify how to retrive values from the arguments. </td></tr>
    <tr><td class="paramname">Sink</td><td>Type of the callable with one string argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_path</td><td>Path of the target executable </td></tr>
    <tr><td class="paramname">create_info</td><td>Parameters on building the fuzzer </td></tr>
    <tr><td class="paramname">initial_inputs</td><td><a class="el" href="classExecInputSet.html">ExecInputSet</a> that contains initial inputs </td></tr>
    <tr><td class="paramname">sink</td><td>Callback function with one string argument to output messages. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>root node of the HierarFlow </dd></dl>

<p class="definition">Definition at line <a class="el" href="libfuzzer_2create_8hpp_source.html#l00315">315</a> of file <a class="el" href="libfuzzer_2create_8hpp_source.html">create.hpp</a>.</p>

</div>
</div>
<a id="af5ef996649b4680eb7941066c14baaf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ef996649b4680eb7941066c14baaf1">&#9670;&nbsp;</a></span>createExecuteAndFeedback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename Ord , typename Sink &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto fuzzuf::algorithm::libfuzzer::createExecuteAndFeedback </td>
          <td>(</td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>target_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1FuzzerCreateInfo.html">FuzzerCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>create_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force_add_to_corpus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>may_delete_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>persistent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict_match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Sink &amp;&#160;</td>
          <td class="paramname"><em>sink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build following flow using HierarFlow</p><ul>
<li><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Execute.html" title="Run target with input specified by the Path, and acquire coverage, outputs, execution result to the v...">Execute</a> target and retrive execution result</li>
<li>Calculate features using execution result</li>
<li>Add to corpus if the execution result is valuable <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Input function type of HierarFlow node </td></tr>
    <tr><td class="paramname">Ord</td><td>Type to specify how to retrive values from the arguments. </td></tr>
    <tr><td class="paramname">Sink</td><td>Type of the callable with one string argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_path</td><td>Path of the target executable </td></tr>
    <tr><td class="paramname">create_info</td><td>Parameters on building the fuzzer </td></tr>
    <tr><td class="paramname">force_add_to_corpus</td><td>If true, the execution result is added to the corpus regardless of features. Otherwise, the execution result is added to the corpus if the execution found novel features. </td></tr>
    <tr><td class="paramname">may_delete_file</td><td>Set may_delete_file attribute to the execution result ( This attribute is not used in current fuzzuf's implementation ). </td></tr>
    <tr><td class="paramname">persistent</td><td>If true, the input is written to both memory and storage. Otherwise, the input is stored on the memory only. </td></tr>
    <tr><td class="paramname">strict_match</td><td>If true, the execution result with completely same unique feature set to existing result causes REPLACE. </td></tr>
    <tr><td class="paramname">sink</td><td>Callback function with one string argument to output messages. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>root node of the HierarFlow </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="libfuzzer_2create_8hpp_source.html#l00116">116</a> of file <a class="el" href="libfuzzer_2create_8hpp_source.html">create.hpp</a>.</p>

</div>
</div>
<a id="af42392d472fd2c2643f27907e8dc262c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42392d472fd2c2643f27907e8dc262c">&#9670;&nbsp;</a></span>createInitialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename Ord , typename Sink &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto fuzzuf::algorithm::libfuzzer::createInitialize </td>
          <td>(</td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>target_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1FuzzerCreateInfo.html">FuzzerCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>create_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classExecInputSet.html">ExecInputSet</a> &amp;&#160;</td>
          <td class="paramname"><em>initial_inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict_match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Sink &amp;&#160;</td>
          <td class="paramname"><em>sink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build following flow using HierarFlow For each initial inputs</p><ul>
<li><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Execute.html" title="Run target with input specified by the Path, and acquire coverage, outputs, execution result to the v...">Execute</a> target and retrive execution result</li>
<li>Calculate features using execution result</li>
<li>Add to corpus <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Input function type of HierarFlow node </td></tr>
    <tr><td class="paramname">Ord</td><td>Type to specify how to retrive values from the arguments. </td></tr>
    <tr><td class="paramname">Sink</td><td>Type of the callable with one string argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_path</td><td>Path of the target executable </td></tr>
    <tr><td class="paramname">create_info</td><td>Parameters on building the fuzzer </td></tr>
    <tr><td class="paramname">initial_inputs</td><td><a class="el" href="classExecInputSet.html">ExecInputSet</a> that contains initial inputs </td></tr>
    <tr><td class="paramname">strict_match</td><td>If true, the execution result with completely same unique feature set to existing result causes REPLACE. </td></tr>
    <tr><td class="paramname">sink</td><td>Callback function with one string argument to output messages. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>root node of the HierarFlow </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="libfuzzer_2create_8hpp_source.html#l00166">166</a> of file <a class="el" href="libfuzzer_2create_8hpp_source.html">create.hpp</a>.</p>

</div>
</div>
<a id="a2a975012c8f7a64f01103be5d00239de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a975012c8f7a64f01103be5d00239de">&#9670;&nbsp;</a></span>createMutator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename Ord &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto fuzzuf::algorithm::libfuzzer::createMutator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1FuzzerCreateInfo.html">FuzzerCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>create_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build libFuzzer's mutator set using HierarFlow </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Input function type of HierarFlow node </td></tr>
    <tr><td class="paramname">Ord</td><td>Type to specify how to retrive values from the arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">create_info</td><td>Parameters on building the fuzzer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>root node of the HierarFlow </dd></dl>

<p class="definition">Definition at line <a class="el" href="libfuzzer_2create_8hpp_source.html#l00040">40</a> of file <a class="el" href="libfuzzer_2create_8hpp_source.html">create.hpp</a>.</p>

</div>
</div>
<a id="a82fd8119ac5d70a0ea83b57effd67a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82fd8119ac5d70a0ea83b57effd67a1e">&#9670;&nbsp;</a></span>createRunone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename Ord , typename Sink &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto fuzzuf::algorithm::libfuzzer::createRunone </td>
          <td>(</td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>target_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1FuzzerCreateInfo.html">FuzzerCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>create_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classExecInputSet.html">ExecInputSet</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Sink &amp;&#160;</td>
          <td class="paramname"><em>sink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build following flow using HierarFlow</p><ul>
<li>Select one input ( or two if crossover is enabled) and mutate it</li>
<li><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1Execute.html" title="Run target with input specified by the Path, and acquire coverage, outputs, execution result to the v...">Execute</a> target using generated input, calculate feature and add to corpus if valuable</li>
<li>Write input to storage if the execution crashed and added to corpus <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Input function type of HierarFlow node </td></tr>
    <tr><td class="paramname">Ord</td><td>Type to specify how to retrive values from the arguments. </td></tr>
    <tr><td class="paramname">Sink</td><td>Type of the callable with one string argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_path</td><td>Path of the target executable </td></tr>
    <tr><td class="paramname">create_info</td><td>Parameters on building the fuzzer </td></tr>
    <tr><td class="paramname">initial_inputs</td><td><a class="el" href="classExecInputSet.html">ExecInputSet</a> that contains initial inputs </td></tr>
    <tr><td class="paramname">sink</td><td>Callback function with one string argument to output messages. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>root node of the HierarFlow </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="libfuzzer_2create_8hpp_source.html#l00219">219</a> of file <a class="el" href="libfuzzer_2create_8hpp_source.html">create.hpp</a>.</p>

</div>
</div>
<a id="a6bf76296037a5043d0a3b97111e63941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf76296037a5043d0a3b97111e63941">&#9670;&nbsp;</a></span>DoNothing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fuzzuf::algorithm::libfuzzer::DoNothing </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function accepting any arguments and does nothing. </p>

<p class="definition">Definition at line <a class="el" href="do__nothing_8hpp_source.html#l00029">29</a> of file <a class="el" href="do__nothing_8hpp_source.html">do_nothing.hpp</a>.</p>

</div>
</div>
<a id="ab3839395a03c170e4b9a8e3d14a1509c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3839395a03c170e4b9a8e3d14a1509c">&#9670;&nbsp;</a></span>FUZZUF_CHECK_CAPABILITY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fuzzuf::algorithm::libfuzzer::FUZZUF_CHECK_CAPABILITY </td>
          <td>(</td>
          <td class="paramtype">HasIncrementUseCount1&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">has_IncrementUseCount1&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::declval&lt; T &amp; &gt;&#160;</td>
          <td class="paramname">).increment_use_count(&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Meta functions to check if the <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1State.html" title="Struct to hold libFuzzer state.">State</a> type has required member functions </p>

</div>
</div>
<a id="a6f83e85f0b133cfa923d59c89850b52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f83e85f0b133cfa923d59c89850b52d">&#9670;&nbsp;</a></span>lflog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto fuzzuf::algorithm::libfuzzer::lflog </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt;  std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Roughly calculate log2 of integer value using number of leading zeros. Corresponding code of original libFuzzer implementation <a href="https://github.com/llvm/llvm-project/blob/llvmorg-12.0.1/compiler-rt/lib/fuzzer/FuzzerUtil.h#L93">https://github.com/llvm/llvm-project/blob/llvmorg-12.0.1/compiler-rt/lib/fuzzer/FuzzerUtil.h#L93</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>value to calculate log2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>calculated value</dd></dl>
<p>Roughly calculate log2 of integer value using leading number zeros. Corresponding code of original libFuzzer implementation <a href="https://github.com/llvm/llvm-project/blob/llvmorg-12.0.1/compiler-rt/lib/fuzzer/FuzzerUtil.h#L93">https://github.com/llvm/llvm-project/blob/llvmorg-12.0.1/compiler-rt/lib/fuzzer/FuzzerUtil.h#L93</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>value to calculate log2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>calculated value </dd></dl>

<p class="definition">Definition at line <a class="el" href="utils_8cpp_source.html#l00036">36</a> of file <a class="el" href="utils_8cpp_source.html">utils.cpp</a>.</p>

</div>
</div>
<a id="a10903973045cb9c57d70dc40c71c2210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10903973045cb9c57d70dc40c71c2210">&#9670;&nbsp;</a></span>random_value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename RNG &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto fuzzuf::algorithm::libfuzzer::random_value </td>
          <td>(</td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em></td><td>)</td>
          <td> -&gt; std::enable_if_t&lt;std::is_integral_v&lt;V&gt; &amp;&amp; std::is_same_v&lt;bool, V&gt;, V&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>libFuzzer compatible random number distribution for boolean</p>
<p>Corresponding code of original libFuzzer implementation <a href="https://github.com/llvm/llvm-project/blob/llvmorg-12.0.1/compiler-rt/lib/fuzzer/FuzzerRandom.h#L22">https://github.com/llvm/llvm-project/blob/llvmorg-12.0.1/compiler-rt/lib/fuzzer/FuzzerRandom.h#L22</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>Integral </td></tr>
    <tr><td class="paramname">RNG</td><td>A type that satisfies standard random number generator concept </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>Random number generator</td></tr>
  </table>
  </dd>
</dl>
<p>libFuzzer compatible random number distribution for integer without max</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>Integral </td></tr>
    <tr><td class="paramname">RNG</td><td>A type that satisfies standard random number generator concept </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>Random number generator </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="algorithms_2libfuzzer_2random_8hpp_source.html#l00082">82</a> of file <a class="el" href="algorithms_2libfuzzer_2random_8hpp_source.html">random.hpp</a>.</p>

</div>
</div>
<a id="ac2ceab672705d6acca0a5d40b643390f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ceab672705d6acca0a5d40b643390f">&#9670;&nbsp;</a></span>random_value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename RNG &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto fuzzuf::algorithm::libfuzzer::random_value </td>
          <td>(</td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::enable_if_t&lt;std::is_integral_v&lt;V&gt;, V&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>libFuzzer compatible random number distribution for integer with max In spite of it is bad practice to use lower bits of values generated by linear congruential generators, libFuzzer is using such distribution.</p>
<p>Corresponding code of original libFuzzer implementation <a href="https://github.com/llvm/llvm-project/blob/llvmorg-12.0.1/compiler-rt/lib/fuzzer/FuzzerRandom.h#L28">https://github.com/llvm/llvm-project/blob/llvmorg-12.0.1/compiler-rt/lib/fuzzer/FuzzerRandom.h#L28</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>Integral type </td></tr>
    <tr><td class="paramname">RNG</td><td>A type that satisfies standard random number generator concept </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>Random number generator </td></tr>
    <tr><td class="paramname">max</td><td>Maximum value (exclusive) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="algorithms_2libfuzzer_2random_8hpp_source.html#l00066">66</a> of file <a class="el" href="algorithms_2libfuzzer_2random_8hpp_source.html">random.hpp</a>.</p>

</div>
</div>
<a id="aa0440b0b01d0e6dafa0027f412f931f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0440b0b01d0e6dafa0027f412f931f7">&#9670;&nbsp;</a></span>toString() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fuzzuf::algorithm::libfuzzer::toString </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1FullCorpus.html">FullCorpus</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>indent_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>indent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serialize <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1FullCorpus.html">FullCorpus</a> into string </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Serialized string is stored in this value </td></tr>
    <tr><td class="paramname">value</td><td>Full corpus to serialize </td></tr>
    <tr><td class="paramname">index_count</td><td>Initial indentation depth </td></tr>
    <tr><td class="paramname">indent</td><td>String to insert for indentation </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="input__info_8cpp_source.html#l00196">196</a> of file <a class="el" href="input__info_8cpp_source.html">input_info.cpp</a>.</p>

</div>
</div>
<a id="a2714a0725c078289ff5982683afbd76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2714a0725c078289ff5982683afbd76a">&#9670;&nbsp;</a></span>toString() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto fuzzuf::algorithm::libfuzzer::toString </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1InputInfo.html">InputInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>indent_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>indent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  bool</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serialize <a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1InputInfo.html" title="execution result This class contains values retrived from executor and scratch values to calculate we...">InputInfo</a> into string </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Serialized string is stored in this value </td></tr>
    <tr><td class="paramname">value</td><td><a class="el" href="structfuzzuf_1_1algorithm_1_1libfuzzer_1_1InputInfo.html" title="execution result This class contains values retrived from executor and scratch values to calculate we...">InputInfo</a> to serialize </td></tr>
    <tr><td class="paramname">index_count</td><td>Initial indentation depth </td></tr>
    <tr><td class="paramname">indent</td><td>String to insert for indentation </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="input__info_8cpp_source.html#l00151">151</a> of file <a class="el" href="input__info_8cpp_source.html">input_info.cpp</a>.</p>

</div>
</div>
<a id="a4b12a1157651367f7add83aa08b7104d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b12a1157651367f7add83aa08b7104d">&#9670;&nbsp;</a></span>toString() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fuzzuf::algorithm::libfuzzer::toString </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacefuzzuf_1_1algorithm_1_1libfuzzer.html#a3a40550db83af1fcbaf15d705b53624a">PartialCorpus</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>indent_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>indent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serialize PartialCorpus into string </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Serialized string is stored in this value </td></tr>
    <tr><td class="paramname">value</td><td>Partial corpus to serialize </td></tr>
    <tr><td class="paramname">index_count</td><td>Initial indentation depth </td></tr>
    <tr><td class="paramname">indent</td><td>String to insert for indentation </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="input__info_8cpp_source.html#l00182">182</a> of file <a class="el" href="input__info_8cpp_source.html">input_info.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aec23950546b6934f1f876b9810d1f8ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec23950546b6934f1f876b9810d1f8ea">&#9670;&nbsp;</a></span>is_piecewise_constant_distribution_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool fuzzuf::algorithm::libfuzzer::is_piecewise_constant_distribution_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    IsPiecewiseConstantDistribution&lt;T&gt;::value</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="random__traits_8hpp_source.html#l00039">39</a> of file <a class="el" href="random__traits_8hpp_source.html">random_traits.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
