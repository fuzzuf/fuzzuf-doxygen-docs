<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fuzzuf: fuzzuf To-Dos</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fuzzuf
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">fuzzuf To-Dos </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document is our to-do list that contains things we would like to do in the future. The list includes not only things that need fixing, but also new features that we are planning to add. Therefore, this document shows the future prospect of fuzzuf.</p>
<p>The listed to-dos are divided into two types: to-dos that require careful consideration and ones that don't.</p><ul>
<li>The former ones would take some time for us to handle because dealing with it would cause a big change on the code base or because we must elaborate designs before starting implmentation. Therefore, <b>even if you would like to contribute to these to-dos and you suddenly send PRs for them without notice and agreement, unfortunately it's very likely that we would be unable to accept your PRs</b>. Alternatively, it would be greatly appreciated if you would join discussions by creating issues. After reaching a conclusion, you and we can start implementation works.</li>
<li>On the other hand, the latter ones are more trivial to do and can be handled if we have time. Sending PRs for them is very helpful anytime.</li>
</ul>
<h1><a class="anchor" id="autotoc_md262"></a>
To-Dos that require careful consideration</h1>
<h2><a class="anchor" id="autotoc_md263"></a>
Unify the designs of RNG (random number generators) and probability distributions</h2>
<p>Considering that most fuzzing algorithms behave stochastically by nature, reproducibility matters a lot. To reproduce the results of prior researches or bugs found during some experiments, we should be able to get a complete control over sources of randomness. As you may know, this demand can be seen also in the field of data science, and many languages and libraries in that field (such as R, Python, numpy and tensorflow, etc.) have the features to that end. As a framework, fuzzuf also should be able to configurate them. In other words, fuzzuf must have its own RNGs and must discourage the users against using other original RNGs that cannot be controlled by fuzzuf. We expect such changes would work also as a kind of dependency injection to make fuzzuf more robust.</p>
<p>Some people may want to use their own implementation of RNGs that are not based on fuzzuf, but such acts are not hygiene. In almost all cases, fuzzing algorithms should not depend on a particular RNG algorithm, nor include it as a part of the algorithm, nor <em>cherry-pick</em> it to hope accidental performance improvements (of course, we don't mean algorithms should work well even if the used RNG is pathologically biased!). On the contrary, all the fuzzing algorithms ideally should use the same RNG algorithm for fair comparison.</p>
<p>At this moment we are thinking about defining the RNG so that the following properties are fulfilled:</p><ul>
<li>It must satisfy <a href="https://en.cppreference.com/w/cpp/named_req/RandomNumberEngine">RandomNumberEngine</a>.<ul>
<li>Especially, it should return a number in the closed interval [0, 2 ^ 64 - 1] uniformly randomly.</li>
<li>Maybe we need to define more variants U([0, 2 ^ 32 -1]), U([a, b]) in case of performance degradation or for ease of use.</li>
</ul>
</li>
<li>It must work fast enough, and must not be biased too much.<ul>
<li>It is debatable to what extent it is allowed to be biased. Are LCGs admissible? How about modulo bias?</li>
<li>Currently the candidates are <a href="http://www.math.sci.hiroshima-u.ac.jp/m-mat/MT/XSADD/index.html">XORSHIFT-ADD</a> or <a href="https://www.pcg-random.org/index.html">PCG</a>.<ul>
<li>c.f. <a href="https://arxiv.org/abs/1810.05313">https://arxiv.org/abs/1810.05313</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Moreover, it would be preferable if fuzzuf has some utilities related to RNGs and distributions. For example, the followings can be considered:</p><ul>
<li>DebugRng: the (non-)random number generator that can be used for tests and debugs. For example, DebugRng({1, 2, 3}) will repeatedly returns 1, 2, 3, 1, 2, ... instead of random numbers. Without this RNG, writing tests may be frustrating sometimes.<ul>
<li>However, we are not sure in what way this should be provided because it's ridiculous to be forced to define something with <code>template&lt;class Rng&gt;</code> just for switching DebugRng and ActualRng in tests and the others.</li>
</ul>
</li>
<li>DebugDistribution: returns the specified sequence of numbers similarly to DebugRng.</li>
</ul>
<p>The following pseudo code shows the currently considered design:</p>
<div class="fragment"><div class="line">fuzzuf::rand::SetGlobalSeed(1234);     <span class="comment">// make all the seeds fixed globally</span></div>
<div class="line"><span class="keyword">auto</span> rng1 = fuzzuf::rand::CreateXSAdd(); <span class="comment">// create a XORSHIFT-ADD RNG seeded with f(1234, 0) (f is TBD)</span></div>
<div class="line">std::uniform_int_distribution&lt;&gt; dist1(0, 3);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;100; i++) {</div>
<div class="line">    std::cout &lt;&lt; dist1(rng1) &lt;&lt; std::endl; <span class="comment">// fuzzuf&#39;s RNGs should be compatible with std</span></div>
<div class="line">}</div>
<div class="line"><span class="keyword">auto</span> rng2 = fuzzuf::rand::CreateXSAdd(); <span class="comment">// create RNG seeded with f(1234, 1)</span></div>
<div class="line">fuzzuf::rand::WalkerDiscreteDistribution&lt;&gt; dist2({10, 20, 30}); <span class="comment">// has the same interface as std::discrete_distribution, but is implemented with Walker&#39;s alias method</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;100; i++) {</div>
<div class="line">    std::cout &lt;&lt; dist2(rng2) &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"><span class="keyword">auto</span> rng3 = fuzzuf::rand::CreateXSAdd(5678); <span class="comment">// create a XORSHIFT-ADD RNG seeded directly with 5678. This constructor will be used mostly for debug purposes.</span></div>
<div class="line">...</div>
</div><!-- fragment --><p>After we define and implement the RNG, we should replace with it all the usages of other RNGs and distributions, such as <code>rand()</code> or <code>fd = fopen("dev/null", "r"); fread(fd, sizeof(u8), 4, buf);</code>. This would take some time.</p>
<h2><a class="anchor" id="autotoc_md264"></a>
Implement fuzzuf-cc, our own instrumentation tool</h2>
<p>As you may notice, we don't have any own instrumentation tool yet. We recommend you to use AFL++'s afl-cc (hereinafter referred to as afl++-cc) for the time being. Technically, we wrote some internal instrumentation tool and have been using it. However, we would like to abandon it because the tool is no more than a subset of afl++-cc. Also, it would be more useful if fuzzuf is compatible with PUTs built with afl++-cc.</p>
<p>However, some algorithms require special kinds of instrumentation that are not implemented in afl++-cc. For example, afl++-cc doesn't support basic block coverage, which is required in VUzzer (To be precise, it doesn't call for a compile-time instrumentation tool because it actually uses pintool. But it's just a possible example). Another example is SpeedNeuzz that uses the modfied version of AFL's edge coverage. We don't think afl++-cc has to be equipped with those instrumentations because usually they perform worse than afl++-cc's refined edge coverage and because AFL++ doesn't need them in the first place. This means fuzzuf must supply <em>fuzzuf-cc</em>, its own instrumentation tool eventually because our goal is to provide a general framework, which is different from AFL++.</p>
<p>We are planning to write fuzzuf-cc in Python 3, whereas AFL and AFL++ wrote their instrumentation tool in C. This is because we realized writing a wrapper of compilers in C makes it not extensible. As described above, we made an internal instrumentation tool by patching afl-cc. Then, we felt that the tool would get messier if we add more features and more options to it, and that we wouldn't want to maintain it. We think the maintenance would be easier if we write it in Python. We will write just a wrapper of compilers and plugins for them, not a compiler itself. Of course, the plugins, such as fuzzuf-llvm-rt.o (equivalent of afl-llvm-rt.o), LLVM Pass, or GCC plugins still must be written in C and C++. Nevertheless, loading the plugins in Python will definitely makes the code concise, which enables us to add and merge a new instrumentation easily.</p>
<p>We are still deciding the followings:</p><ul>
<li>Whether we keep fuzzuf compatible with afl(++)-cc<ul>
<li>Probably we do so</li>
</ul>
</li>
<li>How fuzzuf-cc provides features that are not in AFL, such as basic block coverage<ul>
<li>Should coverages are recorded in the shared memory specified by <code>__AFL_SHM_ID</code> even if basic block coverage is enabled?<ul>
<li>In that case, don't we have to distinguish which type of coverage is used in a given PUT?</li>
</ul>
</li>
<li>Or should we insert something different like <code>__FUZZUF_SHM_ID</code>?</li>
</ul>
</li>
<li>Whether we should make it possible for multiple kinds of instrumentation to be enabled simultaneously<ul>
<li>One of the benefits of doing so is that we can use exactly the same PUT for different fuzzers</li>
<li>However, for fair comparison, it's inevitable to have another PUT to measure coverage as fuzzbench does because the scale of coverage is different between different kinds of coverage</li>
</ul>
</li>
<li>Whether we should insert some section in binaries to distinguish which instrumentation is enabled</li>
</ul>
<p>This to-do is very important to complete libFuzzer because it use some metrics like stack depth to determine the value of a seed, and those metrics are not yet implemented.</p>
<p>Also, we need to replace all the tests that use raw binaries in the repo after this to-do is resolved. That is definitely unsound.</p>
<h2><a class="anchor" id="autotoc_md265"></a>
Support for multiple types of executors in non-AFL family fuzzers</h2>
<p>The current fuzzuf implements <code>AFLExecutorInterface</code> and <code>LibFuzzerExecutorInterface</code> to deal with executors from fuzzing algorithms in a unified manner. These classes wrap the executor with type erasure. There is currently support for multiple executors in the AFL family of fuzzing algorithms, including AFL, AFLFast, DIE, and Nautilus. libFuzzer family has only one executor that meets the requirements, <a class="el" href="classNativeLinuxExecutor.html">NativeLinuxExecutor</a>. For this reason, although the corresponding class is implemented, it is not utilized internally. Also, VUzzer is not utilized other than <a class="el" href="classPinToolExecutor.html">PinToolExecutor</a> because there is no other executor available as well.</p>
<p>In the future, when additional executors are available for these algorithms, we will need to refactor the executors.</p>
<h2><a class="anchor" id="autotoc_md266"></a>
"Daemonize" and enhance the fuzzuf CLI</h2>
<p>This is still just an idea, but it would be nice if fuzzuf has an interface similar to docker and fuzzer instances can be managed like containers. That probably makes the profiling of instances easier. Perhaps even clustering servers is possible like docker swarm.</p>
<p>We can improve the fuzzuf CLI otherwise. For instance, we can make fuzzuf able to receive fuzzer options via other formats than command line arguments, like JSON and YAML. Besides, because we can register subcommands to the <code>fuzzuf</code> command, it's possible to have some utilities like <code>fuzzuf plot</code> or <code>fuzzuf minimize-testcase</code>.</p>
<h2><a class="anchor" id="autotoc_md267"></a>
Update &lt;tt&gt;HierarFlowRoutine::CallSuccessors&lt;/tt&gt;</h2>
<p>As a comment in <code>HierarFlowRoutine::CallSuccessors</code> says, <code><a class="el" href="classHierarFlowCallee.html">HierarFlowCallee</a>&lt;I&gt;::operator()</code> doesn't need to return <code>NullableRef&lt;<a class="el" href="classHierarFlowCallee.html">HierarFlowCallee</a>&lt;I&gt;&gt;</code> now. Formerly, <a class="el" href="classHierarFlowNode.html">HierarFlowNode</a> has been expressed by linked lists, which made us use NullableRef (equivalent of raw pointer) to efficiently describe which node should be executed next. Now that <a class="el" href="classHierarFlowNode.html">HierarFlowNode</a> is implemented with std::vector, <code><a class="el" href="classHierarFlowCallee.html">HierarFlowCallee</a>&lt;I&gt;::operator()</code> can return integers(indices) instead of pointers. Although there is no worry about applying this change, the change is just too big to be suddenly made without notice to the others. Also, we'll have to update some documents.</p>
<h2><a class="anchor" id="autotoc_md268"></a>
Implement more fuzzing algorithms</h2>
<p>The following algorithms are currently planned to be implemented: <br  />
</p>
<ul>
<li>MOpt [^mopt]</li>
<li>Eclipser [^eclipser]</li>
<li>QSYM [^qsym]</li>
</ul>
<p>About some algorithms, it is difficult to determine what is considered a <em>complete</em> implementation. For example, Eclipser is designed differently in v1.0 and v2.0, and we have to discuss whether to implement one or the other (or both). Such algorithms require some discussions.</p>
<p>Among these, the implementation of MOpt is in progress.</p>
<h2><a class="anchor" id="autotoc_md269"></a>
Implement more types of Executor</h2>
<p>The following executors will be implemented in the future:</p>
<ul>
<li>WindowsExecutor (will be implemented with reference to WinAFL [^winafl], WINNIE [^winnie], etc.)</li>
<li>AndroidExecutor</li>
<li>Other <a class="el" href="classExecutor.html">Executor</a> using dynamic instrumentation tools such as Frida and DynamoRIO</li>
</ul>
<h2><a class="anchor" id="autotoc_md270"></a>
Take various benchmarks</h2>
<p>We need to benchmark our implementation to know how fast it really is. In addition, the more benchmarks we have, the more likely we are to notice degrades and bugs. Maybe the results of benchmarking will help us come up with new algorithm ideas. We would like to talk about what kind of benchmarks would be nice to have.</p>
<h1><a class="anchor" id="autotoc_md271"></a>
To-Dos that don't require careful consideration</h1>
<h2><a class="anchor" id="autotoc_md272"></a>
Add the &lt;em&gt;virtual&lt;/em&gt; fork server for the non-fork-server mode of &lt;tt&gt;NativeLinuxExecutor&lt;/tt&gt;</h2>
<p><code><a class="el" href="classNativeLinuxExecutor.html">NativeLinuxExecutor</a></code> has two modes: fork-server mode and non-fork-server mode. These modes are implemented by reference to AFL. However, that implementation has some issues. Its worst drawback is that it heavily uses signals and per-process timers. This means it can't have multiple fuzzer instances in one process (though we are not sure if someone has such purposes in practice). Also, it prevents us from consolidating signal handlers because AFL requires another signal handler for its private use. These issues can be resolved by preparing <em>virtual</em> fork server, which follows the same protocol as the fork server inside PUTs compatible with fork-server mode, and which internally executes a specified PUT with fork() and exec() once it receives the request to do so. Actually, AFL++ has this feature.</p>
<h2><a class="anchor" id="autotoc_md273"></a>
Implement persistent mode in &lt;tt&gt;NativeLinuxExecutor&lt;/tt&gt;</h2>
<p>We should implement this: <a href="https://lcamtuf.blogspot.com/2015/06/new-in-afl-persistent-mode.html">https://lcamtuf.blogspot.com/2015/06/new-in-afl-persistent-mode.html</a> With this mode, the performance of fuzzuf's libFuzzer would be comparable to that of the original libFuzzer.</p>
<h2><a class="anchor" id="autotoc_md274"></a>
Remove raw pointers/buffers from &lt;tt&gt;Mutator&lt;/tt&gt;</h2>
<p>It's too bad <code><a class="el" href="classMutator.html">Mutator</a></code> has some raw pointers as its members, such as <code>u8 *Mutator::outbuf</code> and <code>u8 *Mutator::tmpbuf</code>. These members can be smart pointers or <code>std::vector</code>. We just want to replace them.</p>
<h2><a class="anchor" id="autotoc_md275"></a>
Add CODING_RULE.md and refactor the code in accordance with CODING_RULE.md</h2>
<p>In the past, we didn't have no explicit coding rules. Nevertheless, we have continued developping fuzzuf simultaneously and almost independently of each other. As a result, the code base doesn't look well-organized. This would make the contributors and users confusing, so we must fix it. We have already almost finished creating CODING_RULE.md internally. We will release it after review and formatting is complete. Especially, because we started implementing libFuzzer at a very early stage, the large part of the implementation of libFuzzer doesn't conform to that rules. We will resolve this issue gradually simply because they are too large to fix immediately.</p>
<h1><a class="anchor" id="autotoc_md276"></a>
To-Dos in each fuzzing algorithm (most of which don't require careful consideration)</h1>
<h2><a class="anchor" id="autotoc_md277"></a>
AFL</h2>
<p>This section documents To-Dos of AFL.</p>
<h3><a class="anchor" id="autotoc_md278"></a>
Implement resume mode and parallel fuzzing in AFL</h3>
<p>They are just unimplemented.</p>
<h3><a class="anchor" id="autotoc_md279"></a>
Implement SIGUSR1 Handling on AFL</h3>
<p>This feature is just unimplemented.</p>
<h3><a class="anchor" id="autotoc_md280"></a>
Remove careless templates from AFL</h3>
<p>In the implmentation of AFL, we use a lot of <code>template</code> to allow users to define the derived classes of <code>AFLTestcase</code> and <code>AFLState</code>. But this is just cutting corners. Let us explain what we've done with an example. Let's say, we want to define a function that takes a reference of some struct as an argument. The struct has a member named "x". The function would look like the following:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> SomeFunc(<span class="keyword">const</span> SomeStruct&amp; stru) {</div>
<div class="line">  std::cout &lt;&lt; stru.x &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Next, we would like to generalize this function so that it can accept similar struct types. Specificallt, we should be able to pass to the function the instances of other structs that have the member "x". Obviously, we can do that in the following way:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Struct&gt;</div>
<div class="line"><span class="keywordtype">void</span> SomeFunc(<span class="keyword">const</span> Struct&amp; stru) {</div>
<div class="line">  std::cout &lt;&lt; stru.x &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>But, another possible solution would be to define the virtual member function <code>SomeStruct::GetX()</code>, and to make other structs derive it. Like this way:</p>
<div class="fragment"><div class="line"><span class="comment">// Define SomeStruct::GetX() in advance</span></div>
<div class="line"><span class="keywordtype">void</span> SomeFunc(<span class="keyword">const</span> SomeStruct&amp; stru) {</div>
<div class="line">  std::cout &lt;&lt; stru.GetX() &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>We should rewrite the classes of AFL in the same way eventually.</p>
<h2><a class="anchor" id="autotoc_md281"></a>
IJON</h2>
<p>This section documents To-Dos of IJON.</p>
<h3><a class="anchor" id="autotoc_md282"></a>
Implement annotations</h3>
<p>What IJON proposed is not just a fuzzer, but a set of a fuzzer and an annotation mechanism in PUTs. Unfortunately, the annotation mechanism is not implemented in fuzzuf because fuzzuf doesn't have its own instrumentation tool yet. This should be implemented immediately after fuzzuf-cc becomes ready.</p>
<h3><a class="anchor" id="autotoc_md283"></a>
Test with Super Mario Bros.</h3>
<p>To prove that our IJON fuzzer works well to some extent, one of the most comprehensible tests would be check if the fuzzer can play Super Mario Bros. well, as done in the paper of IJON.</p>
<h2><a class="anchor" id="autotoc_md284"></a>
Nautilus</h2>
<p>This section documents To-Dos of Nautilus.</p>
<h3><a class="anchor" id="autotoc_md285"></a>
Use vector instead of string</h3>
<p>The current parser/unparser of the grammar and rules uses <code>std::string</code> as its data pool instead of <code>std::vector&lt;u8&gt;</code>. This should be changed to <code>std::vector&lt;u8&gt;</code> because <code>std::string</code> is originally not meant to hold unprintable strings.</p>
<h3><a class="anchor" id="autotoc_md286"></a>
Improve queue</h3>
<p>The implementation of the seed queue in the original Nautilus has a lot of room for optimization. The current implementation of fuzzuf is similar to the original one and should be improved.</p>
<p>[^mopt]: Chenyang Lyu, Shouling Ji, Chao Zhang, Yuwei Li, Wei-Han Lee, Yu Song, and Raheem Beyah. 2019. MOpt: Optimized Mutation Scheduling for Fuzzers. In Proceedings of the 28th USENIX Security Symposium (Security'19). [^eclipser]: Jaeseung Choi, Joonun Jang, Choongwoo Han, and Sang K. Cha. 2019. Grey-box Concolic Testing on Binary Code. In Proceedings of the 41st ACM/IEEE International Conference on Software Engineering (ICSE'19). [^qsym]: Insu Yun, Sangho Lee, Meng Xu, Yeongjin Jang, and Taesoo Kim. 2018. QSYM : A Practical Concolic Execution Engine Tailored for Hybrid Fuzzing. In Proceedings of the 27th USENIX Security Symposium (Security'18). [^die]: Soyeon Park, Wen Xu, Insu Yun, Daehee Jang, and Taesoo Kim. 2020. Fuzzing JavaScript Engines with Aspect-preserving Mutation. In Proceedings of the 41st IEEE Symposium on Security and Privacy (S&amp;P’20). [^winafl]: Google Project Zero. "WinAFL" <a href="https://github.com/googleprojectzero/winafl">https://github.com/googleprojectzero/winafl</a> [^winnie]: Jinho Jung, Stephen Tong, Hong Hu, Jungwon Lim, Yonghwi Jin, and Taesoo Kim. 2021. WINNIE: Fuzzing Windows Applications with Harness Synthesis and Fast Cloning. In the Network and Distribution System Security (NDSS'21). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
